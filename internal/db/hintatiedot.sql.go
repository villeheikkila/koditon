// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hintatiedot.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listCitiesWithNeighborhoods = `-- name: ListCitiesWithNeighborhoods :many
SELECT
    hc.hintatiedot_cities_id,
    hc.hintatiedot_cities_name,
    hc.hintatiedot_cities_created_at,
    hc.hintatiedot_cities_updated_at,
    hn.hintatiedot_neighborhoods_id,
    hn.hintatiedot_neighborhoods_name,
    hn.hintatiedot_neighborhoods_created_at,
    hn.hintatiedot_neighborhoods_updated_at,
    hp.hintatiedot_postal_codes_id,
    hp.hintatiedot_postal_codes_code
FROM public.hintatiedot_cities AS hc
LEFT JOIN public.hintatiedot_neighborhoods AS hn
    ON hn.hintatiedot_neighborhoods_city_id = hc.hintatiedot_cities_id
LEFT JOIN public.hintatiedot_postal_codes AS hp
    ON hn.hintatiedot_neighborhoods_postal_code_id = hp.hintatiedot_postal_codes_id
ORDER BY hc.hintatiedot_cities_name, hn.hintatiedot_neighborhoods_name
`

type ListCitiesWithNeighborhoodsRow struct {
	HintatiedotCitiesID               pgtype.UUID        `db:"hintatiedot_cities_id" json:"hintatiedot_cities_id"`
	HintatiedotCitiesName             string             `db:"hintatiedot_cities_name" json:"hintatiedot_cities_name"`
	HintatiedotCitiesCreatedAt        pgtype.Timestamptz `db:"hintatiedot_cities_created_at" json:"hintatiedot_cities_created_at"`
	HintatiedotCitiesUpdatedAt        pgtype.Timestamptz `db:"hintatiedot_cities_updated_at" json:"hintatiedot_cities_updated_at"`
	HintatiedotNeighborhoodsID        pgtype.UUID        `db:"hintatiedot_neighborhoods_id" json:"hintatiedot_neighborhoods_id"`
	HintatiedotNeighborhoodsName      pgtype.Text        `db:"hintatiedot_neighborhoods_name" json:"hintatiedot_neighborhoods_name"`
	HintatiedotNeighborhoodsCreatedAt pgtype.Timestamptz `db:"hintatiedot_neighborhoods_created_at" json:"hintatiedot_neighborhoods_created_at"`
	HintatiedotNeighborhoodsUpdatedAt pgtype.Timestamptz `db:"hintatiedot_neighborhoods_updated_at" json:"hintatiedot_neighborhoods_updated_at"`
	HintatiedotPostalCodesID          pgtype.UUID        `db:"hintatiedot_postal_codes_id" json:"hintatiedot_postal_codes_id"`
	HintatiedotPostalCodesCode        pgtype.Text        `db:"hintatiedot_postal_codes_code" json:"hintatiedot_postal_codes_code"`
}

func (q *Queries) ListCitiesWithNeighborhoods(ctx context.Context) ([]ListCitiesWithNeighborhoodsRow, error) {
	rows, err := q.db.Query(ctx, listCitiesWithNeighborhoods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCitiesWithNeighborhoodsRow{}
	for rows.Next() {
		var i ListCitiesWithNeighborhoodsRow
		if err := rows.Scan(
			&i.HintatiedotCitiesID,
			&i.HintatiedotCitiesName,
			&i.HintatiedotCitiesCreatedAt,
			&i.HintatiedotCitiesUpdatedAt,
			&i.HintatiedotNeighborhoodsID,
			&i.HintatiedotNeighborhoodsName,
			&i.HintatiedotNeighborhoodsCreatedAt,
			&i.HintatiedotNeighborhoodsUpdatedAt,
			&i.HintatiedotPostalCodesID,
			&i.HintatiedotPostalCodesCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByNeighborhoods = `-- name: ListTransactionsByNeighborhoods :many
WITH selected_neighborhoods AS (
    SELECT UNNEST($1::uuid[]) AS neighborhood_id
)
SELECT
    ht.hintatiedot_transactions_id,
    ht.hintatiedot_transactions_description,
    ht.hintatiedot_transactions_type,
    ht.hintatiedot_transactions_area,
    ht.hintatiedot_transactions_price,
    ht.hintatiedot_transactions_price_per_square_meter,
    ht.hintatiedot_transactions_build_year,
    ht.hintatiedot_transactions_floor,
    ht.hintatiedot_transactions_elevator,
    ht.hintatiedot_transactions_condition,
    ht.hintatiedot_transactions_plot,
    ht.hintatiedot_transactions_energy_class,
    ht.hintatiedot_transactions_created_at,
    ht.hintatiedot_transactions_updated_at,
    ht.hintatiedot_transactions_category,
    hn.hintatiedot_neighborhoods_id,
    hn.hintatiedot_neighborhoods_name,
    hp.hintatiedot_postal_codes_code,
    hc.hintatiedot_cities_name
FROM public.hintatiedot_transactions AS ht
JOIN selected_neighborhoods AS sn
    ON sn.neighborhood_id = ht.hintatiedot_neighborhoods_id
LEFT JOIN public.hintatiedot_neighborhoods AS hn
    ON ht.hintatiedot_neighborhoods_id = hn.hintatiedot_neighborhoods_id
LEFT JOIN public.hintatiedot_postal_codes AS hp
    ON hn.hintatiedot_neighborhoods_postal_code_id = hp.hintatiedot_postal_codes_id
LEFT JOIN public.hintatiedot_cities AS hc
    ON hn.hintatiedot_neighborhoods_city_id = hc.hintatiedot_cities_id
ORDER BY ht.hintatiedot_transactions_created_at DESC
`

type ListTransactionsByNeighborhoodsRow struct {
	HintatiedotTransactionsID                  pgtype.UUID        `db:"hintatiedot_transactions_id" json:"hintatiedot_transactions_id"`
	HintatiedotTransactionsDescription         string             `db:"hintatiedot_transactions_description" json:"hintatiedot_transactions_description"`
	HintatiedotTransactionsType                string             `db:"hintatiedot_transactions_type" json:"hintatiedot_transactions_type"`
	HintatiedotTransactionsArea                float64            `db:"hintatiedot_transactions_area" json:"hintatiedot_transactions_area"`
	HintatiedotTransactionsPrice               int32              `db:"hintatiedot_transactions_price" json:"hintatiedot_transactions_price"`
	HintatiedotTransactionsPricePerSquareMeter int32              `db:"hintatiedot_transactions_price_per_square_meter" json:"hintatiedot_transactions_price_per_square_meter"`
	HintatiedotTransactionsBuildYear           int32              `db:"hintatiedot_transactions_build_year" json:"hintatiedot_transactions_build_year"`
	HintatiedotTransactionsFloor               pgtype.Text        `db:"hintatiedot_transactions_floor" json:"hintatiedot_transactions_floor"`
	HintatiedotTransactionsElevator            bool               `db:"hintatiedot_transactions_elevator" json:"hintatiedot_transactions_elevator"`
	HintatiedotTransactionsCondition           pgtype.Text        `db:"hintatiedot_transactions_condition" json:"hintatiedot_transactions_condition"`
	HintatiedotTransactionsPlot                pgtype.Text        `db:"hintatiedot_transactions_plot" json:"hintatiedot_transactions_plot"`
	HintatiedotTransactionsEnergyClass         pgtype.Text        `db:"hintatiedot_transactions_energy_class" json:"hintatiedot_transactions_energy_class"`
	HintatiedotTransactionsCreatedAt           pgtype.Timestamptz `db:"hintatiedot_transactions_created_at" json:"hintatiedot_transactions_created_at"`
	HintatiedotTransactionsUpdatedAt           pgtype.Timestamptz `db:"hintatiedot_transactions_updated_at" json:"hintatiedot_transactions_updated_at"`
	HintatiedotTransactionsCategory            string             `db:"hintatiedot_transactions_category" json:"hintatiedot_transactions_category"`
	HintatiedotNeighborhoodsID                 pgtype.UUID        `db:"hintatiedot_neighborhoods_id" json:"hintatiedot_neighborhoods_id"`
	HintatiedotNeighborhoodsName               pgtype.Text        `db:"hintatiedot_neighborhoods_name" json:"hintatiedot_neighborhoods_name"`
	HintatiedotPostalCodesCode                 pgtype.Text        `db:"hintatiedot_postal_codes_code" json:"hintatiedot_postal_codes_code"`
	HintatiedotCitiesName                      pgtype.Text        `db:"hintatiedot_cities_name" json:"hintatiedot_cities_name"`
}

func (q *Queries) ListTransactionsByNeighborhoods(ctx context.Context, neighborhoodIds []pgtype.UUID) ([]ListTransactionsByNeighborhoodsRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsByNeighborhoods, neighborhoodIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByNeighborhoodsRow{}
	for rows.Next() {
		var i ListTransactionsByNeighborhoodsRow
		if err := rows.Scan(
			&i.HintatiedotTransactionsID,
			&i.HintatiedotTransactionsDescription,
			&i.HintatiedotTransactionsType,
			&i.HintatiedotTransactionsArea,
			&i.HintatiedotTransactionsPrice,
			&i.HintatiedotTransactionsPricePerSquareMeter,
			&i.HintatiedotTransactionsBuildYear,
			&i.HintatiedotTransactionsFloor,
			&i.HintatiedotTransactionsElevator,
			&i.HintatiedotTransactionsCondition,
			&i.HintatiedotTransactionsPlot,
			&i.HintatiedotTransactionsEnergyClass,
			&i.HintatiedotTransactionsCreatedAt,
			&i.HintatiedotTransactionsUpdatedAt,
			&i.HintatiedotTransactionsCategory,
			&i.HintatiedotNeighborhoodsID,
			&i.HintatiedotNeighborhoodsName,
			&i.HintatiedotPostalCodesCode,
			&i.HintatiedotCitiesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertHintatiedotCity = `-- name: UpsertHintatiedotCity :one
INSERT INTO public.hintatiedot_cities (
    hintatiedot_cities_name,
    hintatiedot_cities_created_at,
    hintatiedot_cities_updated_at
) VALUES ($1, now(), now())
ON CONFLICT (hintatiedot_cities_name) DO UPDATE
SET hintatiedot_cities_updated_at = now()
RETURNING hintatiedot_cities_id, hintatiedot_cities_name, hintatiedot_cities_created_at, hintatiedot_cities_updated_at
`

func (q *Queries) UpsertHintatiedotCity(ctx context.Context, hintatiedotCitiesName string) (HintatiedotCity, error) {
	row := q.db.QueryRow(ctx, upsertHintatiedotCity, hintatiedotCitiesName)
	var i HintatiedotCity
	err := row.Scan(
		&i.HintatiedotCitiesID,
		&i.HintatiedotCitiesName,
		&i.HintatiedotCitiesCreatedAt,
		&i.HintatiedotCitiesUpdatedAt,
	)
	return i, err
}

const upsertHintatiedotNeighborhood = `-- name: UpsertHintatiedotNeighborhood :one
INSERT INTO public.hintatiedot_neighborhoods (
    hintatiedot_neighborhoods_name,
    hintatiedot_neighborhoods_city_id,
    hintatiedot_neighborhoods_postal_code_id,
    hintatiedot_neighborhoods_created_at,
    hintatiedot_neighborhoods_updated_at
) VALUES ($1, $2, $3, now(), now())
ON CONFLICT (hintatiedot_neighborhoods_name, hintatiedot_neighborhoods_city_id) DO UPDATE
SET hintatiedot_neighborhoods_postal_code_id = EXCLUDED.hintatiedot_neighborhoods_postal_code_id,
    hintatiedot_neighborhoods_updated_at = now()
RETURNING hintatiedot_neighborhoods_id, hintatiedot_neighborhoods_name, hintatiedot_neighborhoods_city_id, hintatiedot_neighborhoods_postal_code_id, hintatiedot_neighborhoods_created_at, hintatiedot_neighborhoods_updated_at
`

type UpsertHintatiedotNeighborhoodParams struct {
	HintatiedotNeighborhoodsName         string      `db:"hintatiedot_neighborhoods_name" json:"hintatiedot_neighborhoods_name"`
	HintatiedotNeighborhoodsCityID       pgtype.UUID `db:"hintatiedot_neighborhoods_city_id" json:"hintatiedot_neighborhoods_city_id"`
	HintatiedotNeighborhoodsPostalCodeID pgtype.UUID `db:"hintatiedot_neighborhoods_postal_code_id" json:"hintatiedot_neighborhoods_postal_code_id"`
}

func (q *Queries) UpsertHintatiedotNeighborhood(ctx context.Context, arg UpsertHintatiedotNeighborhoodParams) (HintatiedotNeighborhood, error) {
	row := q.db.QueryRow(ctx, upsertHintatiedotNeighborhood, arg.HintatiedotNeighborhoodsName, arg.HintatiedotNeighborhoodsCityID, arg.HintatiedotNeighborhoodsPostalCodeID)
	var i HintatiedotNeighborhood
	err := row.Scan(
		&i.HintatiedotNeighborhoodsID,
		&i.HintatiedotNeighborhoodsName,
		&i.HintatiedotNeighborhoodsCityID,
		&i.HintatiedotNeighborhoodsPostalCodeID,
		&i.HintatiedotNeighborhoodsCreatedAt,
		&i.HintatiedotNeighborhoodsUpdatedAt,
	)
	return i, err
}

const upsertHintatiedotNeighborhoodsBulk = `-- name: UpsertHintatiedotNeighborhoodsBulk :many
INSERT INTO public.hintatiedot_neighborhoods (
    hintatiedot_neighborhoods_name,
    hintatiedot_neighborhoods_city_id,
    hintatiedot_neighborhoods_postal_code_id,
    hintatiedot_neighborhoods_created_at,
    hintatiedot_neighborhoods_updated_at
)
SELECT
    name,
    $1,
    NULL::uuid,
    now(),
    now()
FROM unnest($2::text[]) AS t(name)
ON CONFLICT (hintatiedot_neighborhoods_name, hintatiedot_neighborhoods_city_id) DO UPDATE
SET hintatiedot_neighborhoods_postal_code_id = EXCLUDED.hintatiedot_neighborhoods_postal_code_id,
    hintatiedot_neighborhoods_updated_at = now()
RETURNING hintatiedot_neighborhoods_id, hintatiedot_neighborhoods_name, hintatiedot_neighborhoods_city_id, hintatiedot_neighborhoods_postal_code_id, hintatiedot_neighborhoods_created_at, hintatiedot_neighborhoods_updated_at
`

type UpsertHintatiedotNeighborhoodsBulkParams struct {
	CityID pgtype.UUID `db:"city_id" json:"city_id"`
	Names  []string    `db:"names" json:"names"`
}

func (q *Queries) UpsertHintatiedotNeighborhoodsBulk(ctx context.Context, arg UpsertHintatiedotNeighborhoodsBulkParams) ([]HintatiedotNeighborhood, error) {
	rows, err := q.db.Query(ctx, upsertHintatiedotNeighborhoodsBulk, arg.CityID, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HintatiedotNeighborhood{}
	for rows.Next() {
		var i HintatiedotNeighborhood
		if err := rows.Scan(
			&i.HintatiedotNeighborhoodsID,
			&i.HintatiedotNeighborhoodsName,
			&i.HintatiedotNeighborhoodsCityID,
			&i.HintatiedotNeighborhoodsPostalCodeID,
			&i.HintatiedotNeighborhoodsCreatedAt,
			&i.HintatiedotNeighborhoodsUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertHintatiedotPostalCode = `-- name: UpsertHintatiedotPostalCode :one
INSERT INTO public.hintatiedot_postal_codes (
    hintatiedot_postal_codes_code,
    hintatiedot_postal_codes_city_id,
    hintatiedot_postal_codes_created_at,
    hintatiedot_postal_codes_updated_at
) VALUES ($1, $2, now(), now())
ON CONFLICT (hintatiedot_postal_codes_code) DO UPDATE
SET hintatiedot_postal_codes_city_id = EXCLUDED.hintatiedot_postal_codes_city_id,
    hintatiedot_postal_codes_updated_at = now()
RETURNING hintatiedot_postal_codes_id, hintatiedot_postal_codes_code, hintatiedot_postal_codes_city_id, hintatiedot_postal_codes_created_at, hintatiedot_postal_codes_updated_at
`

type UpsertHintatiedotPostalCodeParams struct {
	HintatiedotPostalCodesCode   string      `db:"hintatiedot_postal_codes_code" json:"hintatiedot_postal_codes_code"`
	HintatiedotPostalCodesCityID pgtype.UUID `db:"hintatiedot_postal_codes_city_id" json:"hintatiedot_postal_codes_city_id"`
}

func (q *Queries) UpsertHintatiedotPostalCode(ctx context.Context, arg UpsertHintatiedotPostalCodeParams) (HintatiedotPostalCode, error) {
	row := q.db.QueryRow(ctx, upsertHintatiedotPostalCode, arg.HintatiedotPostalCodesCode, arg.HintatiedotPostalCodesCityID)
	var i HintatiedotPostalCode
	err := row.Scan(
		&i.HintatiedotPostalCodesID,
		&i.HintatiedotPostalCodesCode,
		&i.HintatiedotPostalCodesCityID,
		&i.HintatiedotPostalCodesCreatedAt,
		&i.HintatiedotPostalCodesUpdatedAt,
	)
	return i, err
}

const upsertHintatiedotPostalCodesBulk = `-- name: UpsertHintatiedotPostalCodesBulk :many
INSERT INTO public.hintatiedot_postal_codes (
    hintatiedot_postal_codes_code,
    hintatiedot_postal_codes_city_id,
    hintatiedot_postal_codes_created_at,
    hintatiedot_postal_codes_updated_at
)
SELECT code, $1, now(), now()
FROM unnest($2::text[]) AS t(code)
ON CONFLICT (hintatiedot_postal_codes_code) DO UPDATE
SET hintatiedot_postal_codes_city_id = EXCLUDED.hintatiedot_postal_codes_city_id,
    hintatiedot_postal_codes_updated_at = now()
RETURNING hintatiedot_postal_codes_id, hintatiedot_postal_codes_code, hintatiedot_postal_codes_city_id, hintatiedot_postal_codes_created_at, hintatiedot_postal_codes_updated_at
`

type UpsertHintatiedotPostalCodesBulkParams struct {
	CityID pgtype.UUID `db:"city_id" json:"city_id"`
	Codes  []string    `db:"codes" json:"codes"`
}

func (q *Queries) UpsertHintatiedotPostalCodesBulk(ctx context.Context, arg UpsertHintatiedotPostalCodesBulkParams) ([]HintatiedotPostalCode, error) {
	rows, err := q.db.Query(ctx, upsertHintatiedotPostalCodesBulk, arg.CityID, arg.Codes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HintatiedotPostalCode{}
	for rows.Next() {
		var i HintatiedotPostalCode
		if err := rows.Scan(
			&i.HintatiedotPostalCodesID,
			&i.HintatiedotPostalCodesCode,
			&i.HintatiedotPostalCodesCityID,
			&i.HintatiedotPostalCodesCreatedAt,
			&i.HintatiedotPostalCodesUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertHintatiedotTransaction = `-- name: UpsertHintatiedotTransaction :one
INSERT INTO public.hintatiedot_transactions (
    hintatiedot_transactions_id,
    hintatiedot_transactions_description,
    hintatiedot_transactions_type,
    hintatiedot_transactions_area,
    hintatiedot_transactions_price,
    hintatiedot_transactions_price_per_square_meter,
    hintatiedot_transactions_build_year,
    hintatiedot_transactions_floor,
    hintatiedot_transactions_elevator,
    hintatiedot_transactions_condition,
    hintatiedot_transactions_plot,
    hintatiedot_transactions_energy_class,
    hintatiedot_transactions_category,
    hintatiedot_neighborhoods_id,
    hintatiedot_transactions_created_at,
    hintatiedot_transactions_updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, now(), now()
)
ON CONFLICT (hintatiedot_transactions_id) DO UPDATE
SET hintatiedot_transactions_description = EXCLUDED.hintatiedot_transactions_description,
    hintatiedot_transactions_type = EXCLUDED.hintatiedot_transactions_type,
    hintatiedot_transactions_area = EXCLUDED.hintatiedot_transactions_area,
    hintatiedot_transactions_price = EXCLUDED.hintatiedot_transactions_price,
    hintatiedot_transactions_price_per_square_meter = EXCLUDED.hintatiedot_transactions_price_per_square_meter,
    hintatiedot_transactions_build_year = EXCLUDED.hintatiedot_transactions_build_year,
    hintatiedot_transactions_floor = EXCLUDED.hintatiedot_transactions_floor,
    hintatiedot_transactions_elevator = EXCLUDED.hintatiedot_transactions_elevator,
    hintatiedot_transactions_condition = EXCLUDED.hintatiedot_transactions_condition,
    hintatiedot_transactions_plot = EXCLUDED.hintatiedot_transactions_plot,
    hintatiedot_transactions_energy_class = EXCLUDED.hintatiedot_transactions_energy_class,
    hintatiedot_transactions_category = EXCLUDED.hintatiedot_transactions_category,
    hintatiedot_neighborhoods_id = EXCLUDED.hintatiedot_neighborhoods_id,
    hintatiedot_transactions_updated_at = now()
RETURNING hintatiedot_transactions_id, hintatiedot_transactions_description, hintatiedot_transactions_type, hintatiedot_transactions_area, hintatiedot_transactions_price, hintatiedot_transactions_price_per_square_meter, hintatiedot_transactions_build_year, hintatiedot_transactions_floor, hintatiedot_transactions_elevator, hintatiedot_transactions_condition, hintatiedot_transactions_plot, hintatiedot_transactions_energy_class, hintatiedot_transactions_created_at, hintatiedot_transactions_updated_at, hintatiedot_transactions_category, hintatiedot_neighborhoods_id
`

type UpsertHintatiedotTransactionParams struct {
	HintatiedotTransactionsID                  pgtype.UUID `db:"hintatiedot_transactions_id" json:"hintatiedot_transactions_id"`
	HintatiedotTransactionsDescription         string      `db:"hintatiedot_transactions_description" json:"hintatiedot_transactions_description"`
	HintatiedotTransactionsType                string      `db:"hintatiedot_transactions_type" json:"hintatiedot_transactions_type"`
	HintatiedotTransactionsArea                float64     `db:"hintatiedot_transactions_area" json:"hintatiedot_transactions_area"`
	HintatiedotTransactionsPrice               int32       `db:"hintatiedot_transactions_price" json:"hintatiedot_transactions_price"`
	HintatiedotTransactionsPricePerSquareMeter int32       `db:"hintatiedot_transactions_price_per_square_meter" json:"hintatiedot_transactions_price_per_square_meter"`
	HintatiedotTransactionsBuildYear           int32       `db:"hintatiedot_transactions_build_year" json:"hintatiedot_transactions_build_year"`
	HintatiedotTransactionsFloor               pgtype.Text `db:"hintatiedot_transactions_floor" json:"hintatiedot_transactions_floor"`
	HintatiedotTransactionsElevator            bool        `db:"hintatiedot_transactions_elevator" json:"hintatiedot_transactions_elevator"`
	HintatiedotTransactionsCondition           pgtype.Text `db:"hintatiedot_transactions_condition" json:"hintatiedot_transactions_condition"`
	HintatiedotTransactionsPlot                pgtype.Text `db:"hintatiedot_transactions_plot" json:"hintatiedot_transactions_plot"`
	HintatiedotTransactionsEnergyClass         pgtype.Text `db:"hintatiedot_transactions_energy_class" json:"hintatiedot_transactions_energy_class"`
	HintatiedotTransactionsCategory            string      `db:"hintatiedot_transactions_category" json:"hintatiedot_transactions_category"`
	HintatiedotNeighborhoodsID                 pgtype.UUID `db:"hintatiedot_neighborhoods_id" json:"hintatiedot_neighborhoods_id"`
}

func (q *Queries) UpsertHintatiedotTransaction(ctx context.Context, arg UpsertHintatiedotTransactionParams) (HintatiedotTransaction, error) {
	row := q.db.QueryRow(ctx, upsertHintatiedotTransaction,
		arg.HintatiedotTransactionsID,
		arg.HintatiedotTransactionsDescription,
		arg.HintatiedotTransactionsType,
		arg.HintatiedotTransactionsArea,
		arg.HintatiedotTransactionsPrice,
		arg.HintatiedotTransactionsPricePerSquareMeter,
		arg.HintatiedotTransactionsBuildYear,
		arg.HintatiedotTransactionsFloor,
		arg.HintatiedotTransactionsElevator,
		arg.HintatiedotTransactionsCondition,
		arg.HintatiedotTransactionsPlot,
		arg.HintatiedotTransactionsEnergyClass,
		arg.HintatiedotTransactionsCategory,
		arg.HintatiedotNeighborhoodsID,
	)
	var i HintatiedotTransaction
	err := row.Scan(
		&i.HintatiedotTransactionsID,
		&i.HintatiedotTransactionsDescription,
		&i.HintatiedotTransactionsType,
		&i.HintatiedotTransactionsArea,
		&i.HintatiedotTransactionsPrice,
		&i.HintatiedotTransactionsPricePerSquareMeter,
		&i.HintatiedotTransactionsBuildYear,
		&i.HintatiedotTransactionsFloor,
		&i.HintatiedotTransactionsElevator,
		&i.HintatiedotTransactionsCondition,
		&i.HintatiedotTransactionsPlot,
		&i.HintatiedotTransactionsEnergyClass,
		&i.HintatiedotTransactionsCreatedAt,
		&i.HintatiedotTransactionsUpdatedAt,
		&i.HintatiedotTransactionsCategory,
		&i.HintatiedotNeighborhoodsID,
	)
	return i, err
}

const upsertHintatiedotTransactionsBulk = `-- name: UpsertHintatiedotTransactionsBulk :execrows
INSERT INTO public.hintatiedot_transactions (
    hintatiedot_transactions_description,
    hintatiedot_transactions_type,
    hintatiedot_transactions_area,
    hintatiedot_transactions_price,
    hintatiedot_transactions_price_per_square_meter,
    hintatiedot_transactions_build_year,
    hintatiedot_transactions_floor,
    hintatiedot_transactions_elevator,
    hintatiedot_transactions_condition,
    hintatiedot_transactions_plot,
    hintatiedot_transactions_energy_class,
    hintatiedot_transactions_category,
    hintatiedot_neighborhoods_id,
    hintatiedot_transactions_created_at,
    hintatiedot_transactions_updated_at
)
SELECT
    descriptions,
    types,
    areas,
    prices,
    price_per_square_meters,
    build_years,
    floors,
    elevators,
    conditions,
    plots,
    energy_classes,
    categories,
    neighborhood_ids,
    now(),
    now()
FROM unnest(
    $1::text[],
    $2::text[],
    $3::double precision[],
    $4::int[],
    $5::int[],
    $6::int[],
    $7::text[],
    $8::boolean[],
    $9::text[],
    $10::text[],
    $11::text[],
    $12::text[],
    $13::uuid[]
) AS t(
    descriptions,
    types,
    areas,
    prices,
    price_per_square_meters,
    build_years,
    floors,
    elevators,
    conditions,
    plots,
    energy_classes,
    categories,
    neighborhood_ids
)
ON CONFLICT (
    hintatiedot_neighborhoods_id,
    hintatiedot_transactions_description,
    hintatiedot_transactions_type,
    hintatiedot_transactions_area,
    hintatiedot_transactions_price,
    hintatiedot_transactions_price_per_square_meter,
    hintatiedot_transactions_build_year,
    hintatiedot_transactions_floor,
    hintatiedot_transactions_elevator,
    hintatiedot_transactions_condition,
    hintatiedot_transactions_plot,
    hintatiedot_transactions_energy_class,
    hintatiedot_transactions_category
) DO UPDATE
SET hintatiedot_transactions_updated_at = now()
`

type UpsertHintatiedotTransactionsBulkParams struct {
	Descriptions         []string      `db:"descriptions" json:"descriptions"`
	Types                []string      `db:"types" json:"types"`
	Areas                []float64     `db:"areas" json:"areas"`
	Prices               []int32       `db:"prices" json:"prices"`
	PricePerSquareMeters []int32       `db:"price_per_square_meters" json:"price_per_square_meters"`
	BuildYears           []int32       `db:"build_years" json:"build_years"`
	Floors               []string      `db:"floors" json:"floors"`
	Elevators            []bool        `db:"elevators" json:"elevators"`
	Conditions           []string      `db:"conditions" json:"conditions"`
	Plots                []string      `db:"plots" json:"plots"`
	EnergyClasses        []string      `db:"energy_classes" json:"energy_classes"`
	Categories           []string      `db:"categories" json:"categories"`
	NeighborhoodIds      []pgtype.UUID `db:"neighborhood_ids" json:"neighborhood_ids"`
}

func (q *Queries) UpsertHintatiedotTransactionsBulk(ctx context.Context, arg UpsertHintatiedotTransactionsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertHintatiedotTransactionsBulk,
		arg.Descriptions,
		arg.Types,
		arg.Areas,
		arg.Prices,
		arg.PricePerSquareMeters,
		arg.BuildYears,
		arg.Floors,
		arg.Elevators,
		arg.Conditions,
		arg.Plots,
		arg.EnergyClasses,
		arg.Categories,
		arg.NeighborhoodIds,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
