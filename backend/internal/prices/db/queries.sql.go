// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listCitiesWithNeighborhoods = `-- name: ListCitiesWithNeighborhoods :many
SELECT
    hc.prices_cities_id,
    hc.prices_cities_name,
    hc.prices_cities_created_at,
    hc.prices_cities_updated_at,
    hn.prices_neighborhoods_id,
    hn.prices_neighborhoods_name,
    hn.prices_neighborhoods_created_at,
    hn.prices_neighborhoods_updated_at,
    hp.prices_postal_codes_id,
    hp.prices_postal_codes_code
FROM public.prices_cities AS hc
LEFT JOIN public.prices_neighborhoods AS hn
    ON hn.prices_neighborhoods_city_id = hc.prices_cities_id
LEFT JOIN public.prices_postal_codes AS hp
    ON hn.prices_neighborhoods_postal_code_id = hp.prices_postal_codes_id
ORDER BY hc.prices_cities_name, hn.prices_neighborhoods_name
`

type ListCitiesWithNeighborhoodsRow struct {
	PricesCitiesID               pgtype.UUID        `db:"prices_cities_id" json:"prices_cities_id"`
	PricesCitiesName             string             `db:"prices_cities_name" json:"prices_cities_name"`
	PricesCitiesCreatedAt        pgtype.Timestamptz `db:"prices_cities_created_at" json:"prices_cities_created_at"`
	PricesCitiesUpdatedAt        pgtype.Timestamptz `db:"prices_cities_updated_at" json:"prices_cities_updated_at"`
	PricesNeighborhoodsID        pgtype.UUID        `db:"prices_neighborhoods_id" json:"prices_neighborhoods_id"`
	PricesNeighborhoodsName      *string            `db:"prices_neighborhoods_name" json:"prices_neighborhoods_name"`
	PricesNeighborhoodsCreatedAt pgtype.Timestamptz `db:"prices_neighborhoods_created_at" json:"prices_neighborhoods_created_at"`
	PricesNeighborhoodsUpdatedAt pgtype.Timestamptz `db:"prices_neighborhoods_updated_at" json:"prices_neighborhoods_updated_at"`
	PricesPostalCodesID          pgtype.UUID        `db:"prices_postal_codes_id" json:"prices_postal_codes_id"`
	PricesPostalCodesCode        *string            `db:"prices_postal_codes_code" json:"prices_postal_codes_code"`
}

func (q *Queries) ListCitiesWithNeighborhoods(ctx context.Context) ([]ListCitiesWithNeighborhoodsRow, error) {
	rows, err := q.db.Query(ctx, listCitiesWithNeighborhoods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCitiesWithNeighborhoodsRow{}
	for rows.Next() {
		var i ListCitiesWithNeighborhoodsRow
		if err := rows.Scan(
			&i.PricesCitiesID,
			&i.PricesCitiesName,
			&i.PricesCitiesCreatedAt,
			&i.PricesCitiesUpdatedAt,
			&i.PricesNeighborhoodsID,
			&i.PricesNeighborhoodsName,
			&i.PricesNeighborhoodsCreatedAt,
			&i.PricesNeighborhoodsUpdatedAt,
			&i.PricesPostalCodesID,
			&i.PricesPostalCodesCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByNeighborhoods = `-- name: ListTransactionsByNeighborhoods :many
WITH selected_neighborhoods AS (
    SELECT UNNEST($1::uuid[]) AS neighborhood_id
)
SELECT
    ht.prices_transactions_id,
    ht.prices_transactions_description,
    ht.prices_transactions_type,
    ht.prices_transactions_area,
    ht.prices_transactions_price,
    ht.prices_transactions_price_per_square_meter,
    ht.prices_transactions_build_year,
    ht.prices_transactions_floor,
    ht.prices_transactions_elevator,
    ht.prices_transactions_condition,
    ht.prices_transactions_plot,
    ht.prices_transactions_energy_class,
    ht.prices_transactions_period_identifier,
    ht.prices_transactions_created_at,
    ht.prices_transactions_updated_at,
    ht.prices_transactions_category,
    hn.prices_neighborhoods_id,
    hn.prices_neighborhoods_name,
    hp.prices_postal_codes_code,
    hc.prices_cities_name
FROM public.prices_transactions AS ht
JOIN selected_neighborhoods AS sn
    ON sn.neighborhood_id = ht.prices_neighborhoods_id
LEFT JOIN public.prices_neighborhoods AS hn
    ON ht.prices_neighborhoods_id = hn.prices_neighborhoods_id
LEFT JOIN public.prices_postal_codes AS hp
    ON hn.prices_neighborhoods_postal_code_id = hp.prices_postal_codes_id
LEFT JOIN public.prices_cities AS hc
    ON hn.prices_neighborhoods_city_id = hc.prices_cities_id
ORDER BY ht.prices_transactions_created_at DESC
`

type ListTransactionsByNeighborhoodsRow struct {
	PricesTransactionsID                  pgtype.UUID        `db:"prices_transactions_id" json:"prices_transactions_id"`
	PricesTransactionsDescription         string             `db:"prices_transactions_description" json:"prices_transactions_description"`
	PricesTransactionsType                string             `db:"prices_transactions_type" json:"prices_transactions_type"`
	PricesTransactionsArea                float64            `db:"prices_transactions_area" json:"prices_transactions_area"`
	PricesTransactionsPrice               int32              `db:"prices_transactions_price" json:"prices_transactions_price"`
	PricesTransactionsPricePerSquareMeter int32              `db:"prices_transactions_price_per_square_meter" json:"prices_transactions_price_per_square_meter"`
	PricesTransactionsBuildYear           int32              `db:"prices_transactions_build_year" json:"prices_transactions_build_year"`
	PricesTransactionsFloor               *string            `db:"prices_transactions_floor" json:"prices_transactions_floor"`
	PricesTransactionsElevator            bool               `db:"prices_transactions_elevator" json:"prices_transactions_elevator"`
	PricesTransactionsCondition           *string            `db:"prices_transactions_condition" json:"prices_transactions_condition"`
	PricesTransactionsPlot                *string            `db:"prices_transactions_plot" json:"prices_transactions_plot"`
	PricesTransactionsEnergyClass         *string            `db:"prices_transactions_energy_class" json:"prices_transactions_energy_class"`
	PricesTransactionsPeriodIdentifier    string             `db:"prices_transactions_period_identifier" json:"prices_transactions_period_identifier"`
	PricesTransactionsCreatedAt           pgtype.Timestamptz `db:"prices_transactions_created_at" json:"prices_transactions_created_at"`
	PricesTransactionsUpdatedAt           pgtype.Timestamptz `db:"prices_transactions_updated_at" json:"prices_transactions_updated_at"`
	PricesTransactionsCategory            string             `db:"prices_transactions_category" json:"prices_transactions_category"`
	PricesNeighborhoodsID                 pgtype.UUID        `db:"prices_neighborhoods_id" json:"prices_neighborhoods_id"`
	PricesNeighborhoodsName               *string            `db:"prices_neighborhoods_name" json:"prices_neighborhoods_name"`
	PricesPostalCodesCode                 *string            `db:"prices_postal_codes_code" json:"prices_postal_codes_code"`
	PricesCitiesName                      *string            `db:"prices_cities_name" json:"prices_cities_name"`
}

func (q *Queries) ListTransactionsByNeighborhoods(ctx context.Context, neighborhoodIds []pgtype.UUID) ([]ListTransactionsByNeighborhoodsRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsByNeighborhoods, neighborhoodIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByNeighborhoodsRow{}
	for rows.Next() {
		var i ListTransactionsByNeighborhoodsRow
		if err := rows.Scan(
			&i.PricesTransactionsID,
			&i.PricesTransactionsDescription,
			&i.PricesTransactionsType,
			&i.PricesTransactionsArea,
			&i.PricesTransactionsPrice,
			&i.PricesTransactionsPricePerSquareMeter,
			&i.PricesTransactionsBuildYear,
			&i.PricesTransactionsFloor,
			&i.PricesTransactionsElevator,
			&i.PricesTransactionsCondition,
			&i.PricesTransactionsPlot,
			&i.PricesTransactionsEnergyClass,
			&i.PricesTransactionsPeriodIdentifier,
			&i.PricesTransactionsCreatedAt,
			&i.PricesTransactionsUpdatedAt,
			&i.PricesTransactionsCategory,
			&i.PricesNeighborhoodsID,
			&i.PricesNeighborhoodsName,
			&i.PricesPostalCodesCode,
			&i.PricesCitiesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPricesCity = `-- name: UpsertPricesCity :one
INSERT INTO public.prices_cities (
    prices_cities_name,
    prices_cities_created_at,
    prices_cities_updated_at
) VALUES ($1, now(), now())
ON CONFLICT (prices_cities_name) DO UPDATE
SET prices_cities_updated_at = now()
RETURNING prices_cities_id, prices_cities_name, prices_cities_created_at, prices_cities_updated_at
`

func (q *Queries) UpsertPricesCity(ctx context.Context, name string) (PricesCity, error) {
	row := q.db.QueryRow(ctx, upsertPricesCity, name)
	var i PricesCity
	err := row.Scan(
		&i.PricesCitiesID,
		&i.PricesCitiesName,
		&i.PricesCitiesCreatedAt,
		&i.PricesCitiesUpdatedAt,
	)
	return i, err
}

const upsertPricesNeighborhood = `-- name: UpsertPricesNeighborhood :one
INSERT INTO public.prices_neighborhoods (
    prices_neighborhoods_name,
    prices_neighborhoods_city_id,
    prices_neighborhoods_postal_code_id,
    prices_neighborhoods_created_at,
    prices_neighborhoods_updated_at
) VALUES ($1, $2, $3, now(), now())
ON CONFLICT (prices_neighborhoods_name, prices_neighborhoods_city_id) DO UPDATE
SET prices_neighborhoods_postal_code_id = EXCLUDED.prices_neighborhoods_postal_code_id,
    prices_neighborhoods_updated_at = now()
RETURNING prices_neighborhoods_id, prices_neighborhoods_name, prices_neighborhoods_city_id, prices_neighborhoods_postal_code_id, prices_neighborhoods_created_at, prices_neighborhoods_updated_at
`

type UpsertPricesNeighborhoodParams struct {
	Name         string      `db:"name" json:"name"`
	CityID       pgtype.UUID `db:"city_id" json:"city_id"`
	PostalCodeID pgtype.UUID `db:"postal_code_id" json:"postal_code_id"`
}

func (q *Queries) UpsertPricesNeighborhood(ctx context.Context, arg *UpsertPricesNeighborhoodParams) (PricesNeighborhood, error) {
	row := q.db.QueryRow(ctx, upsertPricesNeighborhood, arg.Name, arg.CityID, arg.PostalCodeID)
	var i PricesNeighborhood
	err := row.Scan(
		&i.PricesNeighborhoodsID,
		&i.PricesNeighborhoodsName,
		&i.PricesNeighborhoodsCityID,
		&i.PricesNeighborhoodsPostalCodeID,
		&i.PricesNeighborhoodsCreatedAt,
		&i.PricesNeighborhoodsUpdatedAt,
	)
	return i, err
}

const upsertPricesNeighborhoodsBulk = `-- name: UpsertPricesNeighborhoodsBulk :many
INSERT INTO public.prices_neighborhoods (
    prices_neighborhoods_name,
    prices_neighborhoods_city_id,
    prices_neighborhoods_postal_code_id,
    prices_neighborhoods_created_at,
    prices_neighborhoods_updated_at
)
SELECT
    name,
    $1,
    NULL::uuid,
    now(),
    now()
FROM unnest($2::text[]) AS t(name)
ON CONFLICT (prices_neighborhoods_name, prices_neighborhoods_city_id) DO UPDATE
SET prices_neighborhoods_postal_code_id = EXCLUDED.prices_neighborhoods_postal_code_id,
    prices_neighborhoods_updated_at = now()
RETURNING prices_neighborhoods_id, prices_neighborhoods_name, prices_neighborhoods_city_id, prices_neighborhoods_postal_code_id, prices_neighborhoods_created_at, prices_neighborhoods_updated_at
`

type UpsertPricesNeighborhoodsBulkParams struct {
	CityID pgtype.UUID `db:"city_id" json:"city_id"`
	Names  []string    `db:"names" json:"names"`
}

func (q *Queries) UpsertPricesNeighborhoodsBulk(ctx context.Context, arg *UpsertPricesNeighborhoodsBulkParams) ([]PricesNeighborhood, error) {
	rows, err := q.db.Query(ctx, upsertPricesNeighborhoodsBulk, arg.CityID, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PricesNeighborhood{}
	for rows.Next() {
		var i PricesNeighborhood
		if err := rows.Scan(
			&i.PricesNeighborhoodsID,
			&i.PricesNeighborhoodsName,
			&i.PricesNeighborhoodsCityID,
			&i.PricesNeighborhoodsPostalCodeID,
			&i.PricesNeighborhoodsCreatedAt,
			&i.PricesNeighborhoodsUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPricesPostalCode = `-- name: UpsertPricesPostalCode :one
INSERT INTO public.prices_postal_codes (
    prices_postal_codes_code,
    prices_postal_codes_city_id,
    prices_postal_codes_created_at,
    prices_postal_codes_updated_at
) VALUES ($1, $2, now(), now())
ON CONFLICT (prices_postal_codes_code) DO UPDATE
SET prices_postal_codes_city_id = EXCLUDED.prices_postal_codes_city_id,
    prices_postal_codes_updated_at = now()
RETURNING prices_postal_codes_id, prices_postal_codes_code, prices_postal_codes_city_id, prices_postal_codes_created_at, prices_postal_codes_updated_at
`

type UpsertPricesPostalCodeParams struct {
	Code   string      `db:"code" json:"code"`
	CityID pgtype.UUID `db:"city_id" json:"city_id"`
}

func (q *Queries) UpsertPricesPostalCode(ctx context.Context, arg *UpsertPricesPostalCodeParams) (PricesPostalCode, error) {
	row := q.db.QueryRow(ctx, upsertPricesPostalCode, arg.Code, arg.CityID)
	var i PricesPostalCode
	err := row.Scan(
		&i.PricesPostalCodesID,
		&i.PricesPostalCodesCode,
		&i.PricesPostalCodesCityID,
		&i.PricesPostalCodesCreatedAt,
		&i.PricesPostalCodesUpdatedAt,
	)
	return i, err
}

const upsertPricesPostalCodesBulk = `-- name: UpsertPricesPostalCodesBulk :many
INSERT INTO public.prices_postal_codes (
    prices_postal_codes_code,
    prices_postal_codes_city_id,
    prices_postal_codes_created_at,
    prices_postal_codes_updated_at
)
SELECT code, $1, now(), now()
FROM unnest($2::text[]) AS t(code)
ON CONFLICT (prices_postal_codes_code) DO UPDATE
SET prices_postal_codes_city_id = EXCLUDED.prices_postal_codes_city_id,
    prices_postal_codes_updated_at = now()
RETURNING prices_postal_codes_id, prices_postal_codes_code, prices_postal_codes_city_id, prices_postal_codes_created_at, prices_postal_codes_updated_at
`

type UpsertPricesPostalCodesBulkParams struct {
	CityID pgtype.UUID `db:"city_id" json:"city_id"`
	Codes  []string    `db:"codes" json:"codes"`
}

func (q *Queries) UpsertPricesPostalCodesBulk(ctx context.Context, arg *UpsertPricesPostalCodesBulkParams) ([]PricesPostalCode, error) {
	rows, err := q.db.Query(ctx, upsertPricesPostalCodesBulk, arg.CityID, arg.Codes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PricesPostalCode{}
	for rows.Next() {
		var i PricesPostalCode
		if err := rows.Scan(
			&i.PricesPostalCodesID,
			&i.PricesPostalCodesCode,
			&i.PricesPostalCodesCityID,
			&i.PricesPostalCodesCreatedAt,
			&i.PricesPostalCodesUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPricesTransaction = `-- name: UpsertPricesTransaction :one
INSERT INTO public.prices_transactions (
    prices_transactions_description,
    prices_transactions_type,
    prices_transactions_area,
    prices_transactions_price,
    prices_transactions_price_per_square_meter,
    prices_transactions_build_year,
    prices_transactions_floor,
    prices_transactions_elevator,
    prices_transactions_condition,
    prices_transactions_plot,
    prices_transactions_energy_class,
    prices_transactions_category,
    prices_transactions_period_identifier,
    prices_neighborhoods_id,
    prices_transactions_created_at,
    prices_transactions_updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    now(),
    now()
)
ON CONFLICT (
    prices_transactions_description,
    prices_transactions_type,
    prices_transactions_area,
    prices_transactions_price,
    prices_transactions_price_per_square_meter,
    prices_transactions_build_year,
    prices_transactions_floor,
    prices_transactions_elevator,
    prices_transactions_condition,
    prices_transactions_plot,
    prices_transactions_energy_class,
    prices_transactions_category,
    prices_transactions_period_identifier,
    prices_neighborhoods_id
) DO UPDATE
SET prices_transactions_updated_at = now()
RETURNING prices_transactions_id, prices_transactions_neighborhood, prices_transactions_description, prices_transactions_type, prices_transactions_area, prices_transactions_price, prices_transactions_price_per_square_meter, prices_transactions_build_year, prices_transactions_floor, prices_transactions_elevator, prices_transactions_condition, prices_transactions_plot, prices_transactions_energy_class, prices_transactions_period_identifier, prices_transactions_created_at, prices_transactions_updated_at, prices_transactions_category, prices_neighborhoods_id
`

type UpsertPricesTransactionParams struct {
	Description         string      `db:"description" json:"description"`
	Type                string      `db:"type" json:"type"`
	Area                float64     `db:"area" json:"area"`
	Price               int32       `db:"price" json:"price"`
	PricePerSquareMeter int32       `db:"price_per_square_meter" json:"price_per_square_meter"`
	BuildYear           int32       `db:"build_year" json:"build_year"`
	Floor               *string     `db:"floor" json:"floor"`
	Elevator            bool        `db:"elevator" json:"elevator"`
	Condition           *string     `db:"condition" json:"condition"`
	Plot                *string     `db:"plot" json:"plot"`
	EnergyClass         *string     `db:"energy_class" json:"energy_class"`
	Category            string      `db:"category" json:"category"`
	PeriodIdentifier    string      `db:"period_identifier" json:"period_identifier"`
	NeighborhoodID      pgtype.UUID `db:"neighborhood_id" json:"neighborhood_id"`
}

func (q *Queries) UpsertPricesTransaction(ctx context.Context, arg *UpsertPricesTransactionParams) (PricesTransaction, error) {
	row := q.db.QueryRow(ctx, upsertPricesTransaction,
		arg.Description,
		arg.Type,
		arg.Area,
		arg.Price,
		arg.PricePerSquareMeter,
		arg.BuildYear,
		arg.Floor,
		arg.Elevator,
		arg.Condition,
		arg.Plot,
		arg.EnergyClass,
		arg.Category,
		arg.PeriodIdentifier,
		arg.NeighborhoodID,
	)
	var i PricesTransaction
	err := row.Scan(
		&i.PricesTransactionsID,
		&i.PricesTransactionsNeighborhood,
		&i.PricesTransactionsDescription,
		&i.PricesTransactionsType,
		&i.PricesTransactionsArea,
		&i.PricesTransactionsPrice,
		&i.PricesTransactionsPricePerSquareMeter,
		&i.PricesTransactionsBuildYear,
		&i.PricesTransactionsFloor,
		&i.PricesTransactionsElevator,
		&i.PricesTransactionsCondition,
		&i.PricesTransactionsPlot,
		&i.PricesTransactionsEnergyClass,
		&i.PricesTransactionsPeriodIdentifier,
		&i.PricesTransactionsCreatedAt,
		&i.PricesTransactionsUpdatedAt,
		&i.PricesTransactionsCategory,
		&i.PricesNeighborhoodsID,
	)
	return i, err
}

const upsertPricesTransactionsBulk = `-- name: UpsertPricesTransactionsBulk :execrows
INSERT INTO public.prices_transactions (
    prices_transactions_description,
    prices_transactions_type,
    prices_transactions_area,
    prices_transactions_price,
    prices_transactions_price_per_square_meter,
    prices_transactions_build_year,
    prices_transactions_floor,
    prices_transactions_elevator,
    prices_transactions_condition,
    prices_transactions_plot,
    prices_transactions_energy_class,
    prices_transactions_category,
    prices_transactions_period_identifier,
    prices_neighborhoods_id,
    prices_transactions_created_at,
    prices_transactions_updated_at
)
SELECT
    descriptions,
    types,
    areas,
    prices,
    price_per_square_meters,
    build_years,
    floors,
    elevators,
    conditions,
    plots,
    energy_classes,
    categories,
    period_identifiers,
    neighborhood_ids,
    now(),
    now()
FROM unnest(
    $1::text[],
    $2::text[],
    $3::double precision[],
    $4::int[],
    $5::int[],
    $6::int[],
    $7::text[],
    $8::boolean[],
    $9::text[],
    $10::text[],
    $11::text[],
    $12::text[],
    $13::text[],
    $14::uuid[]
) AS t(
    descriptions,
    types,
    areas,
    prices,
    price_per_square_meters,
    build_years,
    floors,
    elevators,
    conditions,
    plots,
    energy_classes,
    categories,
    period_identifiers,
    neighborhood_ids
)
ON CONFLICT (
    prices_neighborhoods_id,
    prices_transactions_description,
    prices_transactions_type,
    prices_transactions_area,
    prices_transactions_price,
    prices_transactions_price_per_square_meter,
    prices_transactions_build_year,
    prices_transactions_floor,
    prices_transactions_elevator,
    prices_transactions_condition,
    prices_transactions_plot,
    prices_transactions_energy_class,
    prices_transactions_category,
    prices_transactions_period_identifier
) DO UPDATE
SET prices_transactions_updated_at = now()
`

type UpsertPricesTransactionsBulkParams struct {
	Descriptions         []string      `db:"descriptions" json:"descriptions"`
	Types                []string      `db:"types" json:"types"`
	Areas                []float64     `db:"areas" json:"areas"`
	Prices               []int32       `db:"prices" json:"prices"`
	PricePerSquareMeters []int32       `db:"price_per_square_meters" json:"price_per_square_meters"`
	BuildYears           []int32       `db:"build_years" json:"build_years"`
	Floors               []string      `db:"floors" json:"floors"`
	Elevators            []bool        `db:"elevators" json:"elevators"`
	Conditions           []string      `db:"conditions" json:"conditions"`
	Plots                []string      `db:"plots" json:"plots"`
	EnergyClasses        []string      `db:"energy_classes" json:"energy_classes"`
	Categories           []string      `db:"categories" json:"categories"`
	PeriodIdentifiers    []string      `db:"period_identifiers" json:"period_identifiers"`
	NeighborhoodIds      []pgtype.UUID `db:"neighborhood_ids" json:"neighborhood_ids"`
}

func (q *Queries) UpsertPricesTransactionsBulk(ctx context.Context, arg *UpsertPricesTransactionsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertPricesTransactionsBulk,
		arg.Descriptions,
		arg.Types,
		arg.Areas,
		arg.Prices,
		arg.PricePerSquareMeters,
		arg.BuildYears,
		arg.Floors,
		arg.Elevators,
		arg.Conditions,
		arg.Plots,
		arg.EnergyClasses,
		arg.Categories,
		arg.PeriodIdentifiers,
		arg.NeighborhoodIds,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
