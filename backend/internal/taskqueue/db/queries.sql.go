// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const callEnqueueTask = `-- name: CallEnqueueTask :one
SELECT task_queue.fnc__enqueue_task($1::bigint) AS message_id
`

func (q *Queries) CallEnqueueTask(ctx context.Context, dollar_1 int64) (int64, error) {
	row := q.db.QueryRow(ctx, callEnqueueTask, dollar_1)
	var message_id int64
	err := row.Scan(&message_id)
	return message_id, err
}

const callMoveToDLQ = `-- name: CallMoveToDLQ :one
SELECT task_queue.fnc__move_to_dlq($1::bigint, $2::jsonb) AS dlq_id
`

func (q *Queries) CallMoveToDLQ(ctx context.Context, column1 int64, column2 json.RawMessage) (int64, error) {
	row := q.db.QueryRow(ctx, callMoveToDLQ, column1, column2)
	var dlq_id int64
	err := row.Scan(&dlq_id)
	return dlq_id, err
}

const callRegisterEntities = `-- name: CallRegisterEntities :one
SELECT task_queue.fnc__register_entities($1::text[], $2::text, $3::text) AS count
`

func (q *Queries) CallRegisterEntities(ctx context.Context, column1 []string, column2 string, column3 string) (int32, error) {
	row := q.db.QueryRow(ctx, callRegisterEntities, column1, column2, column3)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const callRegisterEntity = `-- name: CallRegisterEntity :exec
SELECT task_queue.fnc__register_entity($1::text, $2::text, $3::text, $4::text, $5::jsonb)
`

func (q *Queries) CallRegisterEntity(ctx context.Context, column1 string, column2 string, column3 string, column4 string, column5 json.RawMessage) error {
	_, err := q.db.Exec(ctx, callRegisterEntity,
		column1,
		column2,
		column3,
		column4,
		column5,
	)
	return err
}

const callRequeueFromDLQ = `-- name: CallRequeueFromDLQ :one
SELECT task_queue.fnc__requeue_from_dlq($1::bigint, $2::int, $3::int) AS task_id
`

func (q *Queries) CallRequeueFromDLQ(ctx context.Context, column1 int64, column2 int64, column3 int64) (int64, error) {
	row := q.db.QueryRow(ctx, callRequeueFromDLQ, column1, column2, column3)
	var task_id int64
	err := row.Scan(&task_id)
	return task_id, err
}

const callRequeueStuckTasks = `-- name: CallRequeueStuckTasks :one
SELECT task_queue.fnc__requeue_stuck_tasks() AS count
`

func (q *Queries) CallRequeueStuckTasks(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, callRequeueStuckTasks)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const callScheduleDailySyncs = `-- name: CallScheduleDailySyncs :one
SELECT task_queue.fnc__schedule_daily_syncs($1::text) AS count
`

func (q *Queries) CallScheduleDailySyncs(ctx context.Context, dollar_1 string) (int32, error) {
	row := q.db.QueryRow(ctx, callScheduleDailySyncs, dollar_1)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countDLQEntries = `-- name: CountDLQEntries :one
SELECT
    COUNT(*) AS total,
    COUNT(*) FILTER (WHERE requeued_at IS NULL) AS pending,
    COUNT(*) FILTER (WHERE requeued_at IS NOT NULL) AS requeued
FROM task_queue.dead_letter_queue
`

type CountDLQEntriesRow struct {
	Total    int64 `db:"total" json:"total"`
	Pending  int64 `db:"pending" json:"pending"`
	Requeued int64 `db:"requeued" json:"requeued"`
}

func (q *Queries) CountDLQEntries(ctx context.Context) (CountDLQEntriesRow, error) {
	row := q.db.QueryRow(ctx, countDLQEntries)
	var i CountDLQEntriesRow
	err := row.Scan(&i.Total, &i.Pending, &i.Requeued)
	return i, err
}

const countDLQEntriesByTaskType = `-- name: CountDLQEntriesByTaskType :many
SELECT
    task_type,
    COUNT(*) AS count
FROM task_queue.dead_letter_queue
WHERE requeued_at IS NULL
GROUP BY task_type
ORDER BY count DESC
`

type CountDLQEntriesByTaskTypeRow struct {
	TaskType string `db:"task_type" json:"task_type"`
	Count    int64  `db:"count" json:"count"`
}

func (q *Queries) CountDLQEntriesByTaskType(ctx context.Context) ([]CountDLQEntriesByTaskTypeRow, error) {
	rows, err := q.db.Query(ctx, countDLQEntriesByTaskType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountDLQEntriesByTaskTypeRow{}
	for rows.Next() {
		var i CountDLQEntriesByTaskTypeRow
		if err := rows.Scan(&i.TaskType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countEntitiesByStatus = `-- name: CountEntitiesByStatus :one
SELECT COUNT(*) AS count
FROM task_queue.entity_registry
WHERE status = $1
`

func (q *Queries) CountEntitiesByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countEntitiesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTasksByStatus = `-- name: CountTasksByStatus :one
SELECT COUNT(*) AS count
FROM task_queue.task
WHERE status = $1
`

func (q *Queries) CountTasksByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countTasksByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO task_queue.task (
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    scheduled_for,
    run_on
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING task_id, entity_id, task_type, status, priority, attempt, max_attempts, last_error, worker_id, scheduled_for, started_at, completed_at, run_on, queue_message_id, created_at, updated_at
`

func (q *Queries) CreateTask(ctx context.Context, entityID string, taskType string, status string, priority int32, attempt int32, maxAttempts int32, scheduledFor time.Time, runOn pgtype.Date) (TaskQueueTask, error) {
	row := q.db.QueryRow(ctx, createTask,
		entityID,
		taskType,
		status,
		priority,
		attempt,
		maxAttempts,
		scheduledFor,
		runOn,
	)
	var i TaskQueueTask
	err := row.Scan(
		&i.TaskID,
		&i.EntityID,
		&i.TaskType,
		&i.Status,
		&i.Priority,
		&i.Attempt,
		&i.MaxAttempts,
		&i.LastError,
		&i.WorkerID,
		&i.ScheduledFor,
		&i.StartedAt,
		&i.CompletedAt,
		&i.RunOn,
		&i.QueueMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTaskWithPriority = `-- name: CreateTaskWithPriority :one
INSERT INTO task_queue.task (
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    scheduled_for,
    run_on
) VALUES (
    $1, $2, 'pending', $3, 0, $4, $5, $6
)
RETURNING task_id, entity_id, task_type, status, priority, attempt, max_attempts, last_error, worker_id, scheduled_for, started_at, completed_at, run_on, queue_message_id, created_at, updated_at
`

func (q *Queries) CreateTaskWithPriority(ctx context.Context, entityID string, taskType string, priority int32, maxAttempts int32, scheduledFor time.Time, runOn pgtype.Date) (TaskQueueTask, error) {
	row := q.db.QueryRow(ctx, createTaskWithPriority,
		entityID,
		taskType,
		priority,
		maxAttempts,
		scheduledFor,
		runOn,
	)
	var i TaskQueueTask
	err := row.Scan(
		&i.TaskID,
		&i.EntityID,
		&i.TaskType,
		&i.Status,
		&i.Priority,
		&i.Attempt,
		&i.MaxAttempts,
		&i.LastError,
		&i.WorkerID,
		&i.ScheduledFor,
		&i.StartedAt,
		&i.CompletedAt,
		&i.RunOn,
		&i.QueueMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDLQEntry = `-- name: DeleteDLQEntry :exec
DELETE FROM task_queue.dead_letter_queue
WHERE dlq_id = $1
`

func (q *Queries) DeleteDLQEntry(ctx context.Context, dlqID int64) error {
	_, err := q.db.Exec(ctx, deleteDLQEntry, dlqID)
	return err
}

const deleteEntity = `-- name: DeleteEntity :exec
DELETE FROM task_queue.entity_registry
WHERE entity_id = $1
`

func (q *Queries) DeleteEntity(ctx context.Context, entityID string) error {
	_, err := q.db.Exec(ctx, deleteEntity, entityID)
	return err
}

const deleteOldCompletedTasks = `-- name: DeleteOldCompletedTasks :execrows
DELETE FROM task_queue.task
WHERE status = 'completed'
    AND completed_at < $1
`

func (q *Queries) DeleteOldCompletedTasks(ctx context.Context, completedAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldCompletedTasks, completedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldDLQEntries = `-- name: DeleteOldDLQEntries :execrows
DELETE FROM task_queue.dead_letter_queue
WHERE moved_to_dlq_at < $1
    AND requeued_at IS NOT NULL
`

func (q *Queries) DeleteOldDLQEntries(ctx context.Context, movedToDlqAt time.Time) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldDLQEntries, movedToDlqAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldFailedTasks = `-- name: DeleteOldFailedTasks :execrows
DELETE FROM task_queue.task
WHERE status IN ('failed', 'stopped')
    AND completed_at < $1
`

func (q *Queries) DeleteOldFailedTasks(ctx context.Context, completedAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldFailedTasks, completedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM task_queue.task
WHERE task_id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, taskID int64) error {
	_, err := q.db.Exec(ctx, deleteTask, taskID)
	return err
}

const getDLQEntry = `-- name: GetDLQEntry :one
SELECT
    dlq_id,
    original_task_id,
    entity_id,
    task_type,
    priority,
    total_attempts,
    first_error,
    last_error,
    error_history,
    task_metadata,
    original_created_at,
    first_attempted_at,
    last_attempted_at,
    moved_to_dlq_at,
    requeued_at,
    requeue_count
FROM task_queue.dead_letter_queue
WHERE dlq_id = $1
`

func (q *Queries) GetDLQEntry(ctx context.Context, dlqID int64) (TaskQueueDeadLetterQueue, error) {
	row := q.db.QueryRow(ctx, getDLQEntry, dlqID)
	var i TaskQueueDeadLetterQueue
	err := row.Scan(
		&i.DlqID,
		&i.OriginalTaskID,
		&i.EntityID,
		&i.TaskType,
		&i.Priority,
		&i.TotalAttempts,
		&i.FirstError,
		&i.LastError,
		&i.ErrorHistory,
		&i.TaskMetadata,
		&i.OriginalCreatedAt,
		&i.FirstAttemptedAt,
		&i.LastAttemptedAt,
		&i.MovedToDlqAt,
		&i.RequeuedAt,
		&i.RequeueCount,
	)
	return i, err
}

const getDailyProgress = `-- name: GetDailyProgress :one
SELECT
    COUNT(*) FILTER (WHERE status = 'completed' AND completed_at >= CURRENT_DATE) AS completed_today,
    COUNT(*) FILTER (WHERE status = 'processing') AS in_progress,
    COUNT(*) FILTER (WHERE status = 'pending' AND scheduled_for <= NOW()) AS ready_to_process,
    COUNT(*) FILTER (WHERE status = 'pending' AND scheduled_for > NOW()) AS scheduled_later,
    COUNT(*) FILTER (WHERE status IN ('failed', 'stopped') AND completed_at >= CURRENT_DATE) AS failed_today
FROM task_queue.task
`

type GetDailyProgressRow struct {
	CompletedToday int64 `db:"completed_today" json:"completed_today"`
	InProgress     int64 `db:"in_progress" json:"in_progress"`
	ReadyToProcess int64 `db:"ready_to_process" json:"ready_to_process"`
	ScheduledLater int64 `db:"scheduled_later" json:"scheduled_later"`
	FailedToday    int64 `db:"failed_today" json:"failed_today"`
}

func (q *Queries) GetDailyProgress(ctx context.Context) (GetDailyProgressRow, error) {
	row := q.db.QueryRow(ctx, getDailyProgress)
	var i GetDailyProgressRow
	err := row.Scan(
		&i.CompletedToday,
		&i.InProgress,
		&i.ReadyToProcess,
		&i.ScheduledLater,
		&i.FailedToday,
	)
	return i, err
}

const getEntity = `-- name: GetEntity :one
SELECT
    entity_id,
    entity_type,
    status,
    scheduling_strategy,
    metadata,
    created_at,
    updated_at
FROM task_queue.entity_registry
WHERE entity_id = $1
`

func (q *Queries) GetEntity(ctx context.Context, entityID string) (TaskQueueEntityRegistry, error) {
	row := q.db.QueryRow(ctx, getEntity, entityID)
	var i TaskQueueEntityRegistry
	err := row.Scan(
		&i.EntityID,
		&i.EntityType,
		&i.Status,
		&i.SchedulingStrategy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTask = `-- name: GetTask :one
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE task_id = $1
`

func (q *Queries) GetTask(ctx context.Context, taskID int64) (TaskQueueTask, error) {
	row := q.db.QueryRow(ctx, getTask, taskID)
	var i TaskQueueTask
	err := row.Scan(
		&i.TaskID,
		&i.EntityID,
		&i.TaskType,
		&i.Status,
		&i.Priority,
		&i.Attempt,
		&i.MaxAttempts,
		&i.LastError,
		&i.WorkerID,
		&i.ScheduledFor,
		&i.StartedAt,
		&i.CompletedAt,
		&i.RunOn,
		&i.QueueMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskByEntityAndDate = `-- name: GetTaskByEntityAndDate :one
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE entity_id = $1
    AND task_type = $2
    AND run_on = $3
`

func (q *Queries) GetTaskByEntityAndDate(ctx context.Context, entityID string, taskType string, runOn pgtype.Date) (TaskQueueTask, error) {
	row := q.db.QueryRow(ctx, getTaskByEntityAndDate, entityID, taskType, runOn)
	var i TaskQueueTask
	err := row.Scan(
		&i.TaskID,
		&i.EntityID,
		&i.TaskType,
		&i.Status,
		&i.Priority,
		&i.Attempt,
		&i.MaxAttempts,
		&i.LastError,
		&i.WorkerID,
		&i.ScheduledFor,
		&i.StartedAt,
		&i.CompletedAt,
		&i.RunOn,
		&i.QueueMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskStatusSummary = `-- name: GetTaskStatusSummary :one
SELECT
    COUNT(*) FILTER (WHERE status = 'pending') AS pending,
    COUNT(*) FILTER (WHERE status = 'processing') AS processing,
    COUNT(*) FILTER (WHERE status = 'completed') AS completed,
    COUNT(*) FILTER (WHERE status = 'failed') AS failed,
    COUNT(*) FILTER (WHERE status = 'stopped') AS stopped,
    COUNT(*) AS total,
    COALESCE(ROUND(100.0 * COUNT(*) FILTER (WHERE status = 'completed') / NULLIF(COUNT(*), 0), 2), 0) AS success_rate_pct
FROM task_queue.task
`

type GetTaskStatusSummaryRow struct {
	Pending        int64          `db:"pending" json:"pending"`
	Processing     int64          `db:"processing" json:"processing"`
	Completed      int64          `db:"completed" json:"completed"`
	Failed         int64          `db:"failed" json:"failed"`
	Stopped        int64          `db:"stopped" json:"stopped"`
	Total          int64          `db:"total" json:"total"`
	SuccessRatePct pgtype.Numeric `db:"success_rate_pct" json:"success_rate_pct"`
}

func (q *Queries) GetTaskStatusSummary(ctx context.Context) (GetTaskStatusSummaryRow, error) {
	row := q.db.QueryRow(ctx, getTaskStatusSummary)
	var i GetTaskStatusSummaryRow
	err := row.Scan(
		&i.Pending,
		&i.Processing,
		&i.Completed,
		&i.Failed,
		&i.Stopped,
		&i.Total,
		&i.SuccessRatePct,
	)
	return i, err
}

const getTasksByRunDate = `-- name: GetTasksByRunDate :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE run_on = $1
ORDER BY priority DESC, scheduled_for ASC
`

func (q *Queries) GetTasksByRunDate(ctx context.Context, runOn pgtype.Date) ([]TaskQueueTask, error) {
	rows, err := q.db.Query(ctx, getTasksByRunDate, runOn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueTask{}
	for rows.Next() {
		var i TaskQueueTask
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertIntoDLQ = `-- name: InsertIntoDLQ :one

INSERT INTO task_queue.dead_letter_queue (
    original_task_id,
    entity_id,
    task_type,
    priority,
    total_attempts,
    first_error,
    last_error,
    error_history,
    task_metadata,
    original_created_at,
    first_attempted_at,
    last_attempted_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING dlq_id, original_task_id, entity_id, task_type, priority, total_attempts, first_error, last_error, error_history, task_metadata, original_created_at, first_attempted_at, last_attempted_at, moved_to_dlq_at, requeued_at, requeue_count
`

// ============================================================================
// Dead Letter Queue (DLQ) Queries
// ============================================================================
func (q *Queries) InsertIntoDLQ(ctx context.Context, originalTaskID int64, entityID string, taskType string, priority int32, totalAttempts int32, firstError pgtype.Text, lastError string, errorHistory json.RawMessage, taskMetadata []byte, originalCreatedAt time.Time, firstAttemptedAt pgtype.Timestamptz, lastAttemptedAt time.Time) (TaskQueueDeadLetterQueue, error) {
	row := q.db.QueryRow(ctx, insertIntoDLQ,
		originalTaskID,
		entityID,
		taskType,
		priority,
		totalAttempts,
		firstError,
		lastError,
		errorHistory,
		taskMetadata,
		originalCreatedAt,
		firstAttemptedAt,
		lastAttemptedAt,
	)
	var i TaskQueueDeadLetterQueue
	err := row.Scan(
		&i.DlqID,
		&i.OriginalTaskID,
		&i.EntityID,
		&i.TaskType,
		&i.Priority,
		&i.TotalAttempts,
		&i.FirstError,
		&i.LastError,
		&i.ErrorHistory,
		&i.TaskMetadata,
		&i.OriginalCreatedAt,
		&i.FirstAttemptedAt,
		&i.LastAttemptedAt,
		&i.MovedToDlqAt,
		&i.RequeuedAt,
		&i.RequeueCount,
	)
	return i, err
}

const listActiveEntities = `-- name: ListActiveEntities :many
SELECT
    entity_id,
    entity_type,
    status,
    scheduling_strategy,
    metadata,
    created_at,
    updated_at
FROM task_queue.entity_registry
WHERE status = 'active'
ORDER BY entity_id
`

func (q *Queries) ListActiveEntities(ctx context.Context) ([]TaskQueueEntityRegistry, error) {
	rows, err := q.db.Query(ctx, listActiveEntities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueEntityRegistry{}
	for rows.Next() {
		var i TaskQueueEntityRegistry
		if err := rows.Scan(
			&i.EntityID,
			&i.EntityType,
			&i.Status,
			&i.SchedulingStrategy,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveWorkers = `-- name: ListActiveWorkers :many
SELECT
    worker_id,
    COUNT(*) AS active_tasks,
    MIN(started_at) AS oldest_task_started,
    EXTRACT(EPOCH FROM (NOW() - MIN(started_at)))::INT AS oldest_task_age_seconds
FROM task_queue.task
WHERE status = 'processing'
    AND worker_id IS NOT NULL
GROUP BY worker_id
ORDER BY oldest_task_started
`

type ListActiveWorkersRow struct {
	WorkerID             pgtype.Text `db:"worker_id" json:"worker_id"`
	ActiveTasks          int64       `db:"active_tasks" json:"active_tasks"`
	OldestTaskStarted    time.Time   `db:"oldest_task_started" json:"oldest_task_started"`
	OldestTaskAgeSeconds int64       `db:"oldest_task_age_seconds" json:"oldest_task_age_seconds"`
}

func (q *Queries) ListActiveWorkers(ctx context.Context) ([]ListActiveWorkersRow, error) {
	rows, err := q.db.Query(ctx, listActiveWorkers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveWorkersRow{}
	for rows.Next() {
		var i ListActiveWorkersRow
		if err := rows.Scan(
			&i.WorkerID,
			&i.ActiveTasks,
			&i.OldestTaskStarted,
			&i.OldestTaskAgeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQEntries = `-- name: ListDLQEntries :many
SELECT
    dlq_id,
    original_task_id,
    entity_id,
    task_type,
    priority,
    total_attempts,
    first_error,
    last_error,
    error_history,
    task_metadata,
    original_created_at,
    first_attempted_at,
    last_attempted_at,
    moved_to_dlq_at,
    requeued_at,
    requeue_count
FROM task_queue.dead_letter_queue
ORDER BY moved_to_dlq_at DESC
LIMIT $1 OFFSET $2
`

func (q *Queries) ListDLQEntries(ctx context.Context, limit int64, offset int64) ([]TaskQueueDeadLetterQueue, error) {
	rows, err := q.db.Query(ctx, listDLQEntries, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueDeadLetterQueue{}
	for rows.Next() {
		var i TaskQueueDeadLetterQueue
		if err := rows.Scan(
			&i.DlqID,
			&i.OriginalTaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Priority,
			&i.TotalAttempts,
			&i.FirstError,
			&i.LastError,
			&i.ErrorHistory,
			&i.TaskMetadata,
			&i.OriginalCreatedAt,
			&i.FirstAttemptedAt,
			&i.LastAttemptedAt,
			&i.MovedToDlqAt,
			&i.RequeuedAt,
			&i.RequeueCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQEntriesByEntity = `-- name: ListDLQEntriesByEntity :many
SELECT
    dlq_id,
    original_task_id,
    entity_id,
    task_type,
    priority,
    total_attempts,
    first_error,
    last_error,
    error_history,
    task_metadata,
    original_created_at,
    first_attempted_at,
    last_attempted_at,
    moved_to_dlq_at,
    requeued_at,
    requeue_count
FROM task_queue.dead_letter_queue
WHERE entity_id = $1
ORDER BY moved_to_dlq_at DESC
LIMIT $2 OFFSET $3
`

func (q *Queries) ListDLQEntriesByEntity(ctx context.Context, entityID string, limit int64, offset int64) ([]TaskQueueDeadLetterQueue, error) {
	rows, err := q.db.Query(ctx, listDLQEntriesByEntity, entityID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueDeadLetterQueue{}
	for rows.Next() {
		var i TaskQueueDeadLetterQueue
		if err := rows.Scan(
			&i.DlqID,
			&i.OriginalTaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Priority,
			&i.TotalAttempts,
			&i.FirstError,
			&i.LastError,
			&i.ErrorHistory,
			&i.TaskMetadata,
			&i.OriginalCreatedAt,
			&i.FirstAttemptedAt,
			&i.LastAttemptedAt,
			&i.MovedToDlqAt,
			&i.RequeuedAt,
			&i.RequeueCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQEntriesByTaskType = `-- name: ListDLQEntriesByTaskType :many
SELECT
    dlq_id,
    original_task_id,
    entity_id,
    task_type,
    priority,
    total_attempts,
    first_error,
    last_error,
    error_history,
    task_metadata,
    original_created_at,
    first_attempted_at,
    last_attempted_at,
    moved_to_dlq_at,
    requeued_at,
    requeue_count
FROM task_queue.dead_letter_queue
WHERE task_type = $1
    AND requeued_at IS NULL
ORDER BY moved_to_dlq_at DESC
LIMIT $2 OFFSET $3
`

func (q *Queries) ListDLQEntriesByTaskType(ctx context.Context, taskType string, limit int64, offset int64) ([]TaskQueueDeadLetterQueue, error) {
	rows, err := q.db.Query(ctx, listDLQEntriesByTaskType, taskType, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueDeadLetterQueue{}
	for rows.Next() {
		var i TaskQueueDeadLetterQueue
		if err := rows.Scan(
			&i.DlqID,
			&i.OriginalTaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Priority,
			&i.TotalAttempts,
			&i.FirstError,
			&i.LastError,
			&i.ErrorHistory,
			&i.TaskMetadata,
			&i.OriginalCreatedAt,
			&i.FirstAttemptedAt,
			&i.LastAttemptedAt,
			&i.MovedToDlqAt,
			&i.RequeuedAt,
			&i.RequeueCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQEntriesNotRequeued = `-- name: ListDLQEntriesNotRequeued :many
SELECT
    dlq_id,
    original_task_id,
    entity_id,
    task_type,
    priority,
    total_attempts,
    first_error,
    last_error,
    error_history,
    task_metadata,
    original_created_at,
    first_attempted_at,
    last_attempted_at,
    moved_to_dlq_at,
    requeued_at,
    requeue_count
FROM task_queue.dead_letter_queue
WHERE requeued_at IS NULL
ORDER BY moved_to_dlq_at DESC
LIMIT $1 OFFSET $2
`

func (q *Queries) ListDLQEntriesNotRequeued(ctx context.Context, limit int64, offset int64) ([]TaskQueueDeadLetterQueue, error) {
	rows, err := q.db.Query(ctx, listDLQEntriesNotRequeued, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueDeadLetterQueue{}
	for rows.Next() {
		var i TaskQueueDeadLetterQueue
		if err := rows.Scan(
			&i.DlqID,
			&i.OriginalTaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Priority,
			&i.TotalAttempts,
			&i.FirstError,
			&i.LastError,
			&i.ErrorHistory,
			&i.TaskMetadata,
			&i.OriginalCreatedAt,
			&i.FirstAttemptedAt,
			&i.LastAttemptedAt,
			&i.MovedToDlqAt,
			&i.RequeuedAt,
			&i.RequeueCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntities = `-- name: ListEntities :many
SELECT
    entity_id,
    entity_type,
    status,
    scheduling_strategy,
    metadata,
    created_at,
    updated_at
FROM task_queue.entity_registry
ORDER BY entity_id
`

func (q *Queries) ListEntities(ctx context.Context) ([]TaskQueueEntityRegistry, error) {
	rows, err := q.db.Query(ctx, listEntities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueEntityRegistry{}
	for rows.Next() {
		var i TaskQueueEntityRegistry
		if err := rows.Scan(
			&i.EntityID,
			&i.EntityType,
			&i.Status,
			&i.SchedulingStrategy,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE status = 'pending'
    AND scheduled_for <= NOW()
ORDER BY priority DESC, scheduled_for ASC
LIMIT $1
`

// Orders by priority DESC (higher first), then scheduled_for ASC (older first)
func (q *Queries) ListPendingTasks(ctx context.Context, limit int64) ([]TaskQueueTask, error) {
	rows, err := q.db.Query(ctx, listPendingTasks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueTask{}
	for rows.Next() {
		var i TaskQueueTask
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentFailures = `-- name: ListRecentFailures :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    completed_at AS failed_at,
    created_at,
    updated_at
FROM task_queue.task
WHERE status IN ('failed', 'stopped')
ORDER BY completed_at DESC
LIMIT $1
`

type ListRecentFailuresRow struct {
	TaskID      int64              `db:"task_id" json:"task_id"`
	EntityID    string             `db:"entity_id" json:"entity_id"`
	TaskType    string             `db:"task_type" json:"task_type"`
	Status      string             `db:"status" json:"status"`
	Priority    int64              `db:"priority" json:"priority"`
	Attempt     int64              `db:"attempt" json:"attempt"`
	MaxAttempts int64              `db:"max_attempts" json:"max_attempts"`
	LastError   pgtype.Text        `db:"last_error" json:"last_error"`
	FailedAt    pgtype.Timestamptz `db:"failed_at" json:"failed_at"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListRecentFailures(ctx context.Context, limit int64) ([]ListRecentFailuresRow, error) {
	rows, err := q.db.Query(ctx, listRecentFailures, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentFailuresRow{}
	for rows.Next() {
		var i ListRecentFailuresRow
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.FailedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTasks = `-- name: ListScheduledTasks :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE status = 'pending'
    AND scheduled_for > NOW()
ORDER BY priority DESC, scheduled_for ASC
LIMIT $1 OFFSET $2
`

func (q *Queries) ListScheduledTasks(ctx context.Context, limit int64, offset int64) ([]TaskQueueTask, error) {
	rows, err := q.db.Query(ctx, listScheduledTasks, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueTask{}
	for rows.Next() {
		var i TaskQueueTask
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStuckTasks = `-- name: ListStuckTasks :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at,
    EXTRACT(EPOCH FROM (NOW() - started_at))::INT AS stuck_seconds
FROM task_queue.task
WHERE status = 'processing'
    AND updated_at < NOW() - INTERVAL '10 minutes'
ORDER BY started_at
`

type ListStuckTasksRow struct {
	TaskID         int64              `db:"task_id" json:"task_id"`
	EntityID       string             `db:"entity_id" json:"entity_id"`
	TaskType       string             `db:"task_type" json:"task_type"`
	Status         string             `db:"status" json:"status"`
	Priority       int64              `db:"priority" json:"priority"`
	Attempt        int64              `db:"attempt" json:"attempt"`
	MaxAttempts    int64              `db:"max_attempts" json:"max_attempts"`
	LastError      pgtype.Text        `db:"last_error" json:"last_error"`
	WorkerID       pgtype.Text        `db:"worker_id" json:"worker_id"`
	ScheduledFor   pgtype.Timestamptz `db:"scheduled_for" json:"scheduled_for"`
	StartedAt      pgtype.Timestamptz `db:"started_at" json:"started_at"`
	CompletedAt    pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	RunOn          pgtype.Date        `db:"run_on" json:"run_on"`
	QueueMessageID pgtype.Int8        `db:"queue_message_id" json:"queue_message_id"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	StuckSeconds   int64              `db:"stuck_seconds" json:"stuck_seconds"`
}

func (q *Queries) ListStuckTasks(ctx context.Context) ([]ListStuckTasksRow, error) {
	rows, err := q.db.Query(ctx, listStuckTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStuckTasksRow{}
	for rows.Next() {
		var i ListStuckTasksRow
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StuckSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

func (q *Queries) ListTasks(ctx context.Context, limit int64, offset int64) ([]TaskQueueTask, error) {
	rows, err := q.db.Query(ctx, listTasks, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueTask{}
	for rows.Next() {
		var i TaskQueueTask
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByEntity = `-- name: ListTasksByEntity :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE entity_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

func (q *Queries) ListTasksByEntity(ctx context.Context, entityID string, limit int64, offset int64) ([]TaskQueueTask, error) {
	rows, err := q.db.Query(ctx, listTasksByEntity, entityID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueTask{}
	for rows.Next() {
		var i TaskQueueTask
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByStatus = `-- name: ListTasksByStatus :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE status = $1
ORDER BY priority DESC, created_at DESC
LIMIT $2 OFFSET $3
`

func (q *Queries) ListTasksByStatus(ctx context.Context, status string, limit int64, offset int64) ([]TaskQueueTask, error) {
	rows, err := q.db.Query(ctx, listTasksByStatus, status, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueTask{}
	for rows.Next() {
		var i TaskQueueTask
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByWorker = `-- name: ListTasksByWorker :many
SELECT
    task_id,
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    last_error,
    worker_id,
    scheduled_for,
    started_at,
    completed_at,
    run_on,
    queue_message_id,
    created_at,
    updated_at
FROM task_queue.task
WHERE worker_id = $1
    AND status = 'processing'
ORDER BY started_at
`

func (q *Queries) ListTasksByWorker(ctx context.Context, workerID pgtype.Text) ([]TaskQueueTask, error) {
	rows, err := q.db.Query(ctx, listTasksByWorker, workerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskQueueTask{}
	for rows.Next() {
		var i TaskQueueTask
		if err := rows.Scan(
			&i.TaskID,
			&i.EntityID,
			&i.TaskType,
			&i.Status,
			&i.Priority,
			&i.Attempt,
			&i.MaxAttempts,
			&i.LastError,
			&i.WorkerID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RunOn,
			&i.QueueMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDLQEntryRequeued = `-- name: MarkDLQEntryRequeued :exec
UPDATE task_queue.dead_letter_queue
SET
    requeued_at = NOW(),
    requeue_count = requeue_count + 1
WHERE dlq_id = $1
`

func (q *Queries) MarkDLQEntryRequeued(ctx context.Context, dlqID int64) error {
	_, err := q.db.Exec(ctx, markDLQEntryRequeued, dlqID)
	return err
}

const updateEntityStatus = `-- name: UpdateEntityStatus :exec
UPDATE task_queue.entity_registry
SET
    status = $2,
    updated_at = NOW()
WHERE entity_id = $1
`

func (q *Queries) UpdateEntityStatus(ctx context.Context, entityID string, status string) error {
	_, err := q.db.Exec(ctx, updateEntityStatus, entityID, status)
	return err
}

const updateTaskPriority = `-- name: UpdateTaskPriority :exec
UPDATE task_queue.task
SET
    priority = $2,
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskPriority(ctx context.Context, taskID int64, priority int32) error {
	_, err := q.db.Exec(ctx, updateTaskPriority, taskID, priority)
	return err
}

const updateTaskQueueMessageId = `-- name: UpdateTaskQueueMessageId :exec
UPDATE task_queue.task
SET
    queue_message_id = $2,
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskQueueMessageId(ctx context.Context, taskID int64, queueMessageID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, updateTaskQueueMessageId, taskID, queueMessageID)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE task_queue.task
SET
    status = $2,
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskStatus(ctx context.Context, taskID int64, status string) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, taskID, status)
	return err
}

const updateTaskToCompleted = `-- name: UpdateTaskToCompleted :exec
UPDATE task_queue.task
SET
    status = 'completed',
    last_error = NULL,
    completed_at = NOW(),
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskToCompleted(ctx context.Context, taskID int64) error {
	_, err := q.db.Exec(ctx, updateTaskToCompleted, taskID)
	return err
}

const updateTaskToFailed = `-- name: UpdateTaskToFailed :exec
UPDATE task_queue.task
SET
    status = 'failed',
    last_error = $2,
    completed_at = NOW(),
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskToFailed(ctx context.Context, taskID int64, lastError pgtype.Text) error {
	_, err := q.db.Exec(ctx, updateTaskToFailed, taskID, lastError)
	return err
}

const updateTaskToPending = `-- name: UpdateTaskToPending :exec
UPDATE task_queue.task
SET
    status = 'pending',
    attempt = attempt + 1,
    worker_id = NULL,
    scheduled_for = $2,
    started_at = NULL,
    queue_message_id = NULL,
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskToPending(ctx context.Context, taskID int64, scheduledFor time.Time) error {
	_, err := q.db.Exec(ctx, updateTaskToPending, taskID, scheduledFor)
	return err
}

const updateTaskToPendingForRetry = `-- name: UpdateTaskToPendingForRetry :exec
UPDATE task_queue.task
SET
    status = 'pending',
    worker_id = NULL,
    scheduled_for = $2,
    started_at = NULL,
    queue_message_id = NULL,
    updated_at = NOW()
WHERE task_id = $1
`

// Used when retrying a failed task - does NOT increment attempt since UpdateTaskToProcessing already did
func (q *Queries) UpdateTaskToPendingForRetry(ctx context.Context, taskID int64, scheduledFor time.Time) error {
	_, err := q.db.Exec(ctx, updateTaskToPendingForRetry, taskID, scheduledFor)
	return err
}

const updateTaskToProcessing = `-- name: UpdateTaskToProcessing :exec
UPDATE task_queue.task
SET
    status = 'processing',
    attempt = attempt + 1,
    worker_id = $2,
    started_at = CASE WHEN started_at IS NULL THEN NOW() ELSE started_at END,
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskToProcessing(ctx context.Context, taskID int64, workerID pgtype.Text) error {
	_, err := q.db.Exec(ctx, updateTaskToProcessing, taskID, workerID)
	return err
}

const upsertEntity = `-- name: UpsertEntity :one
INSERT INTO task_queue.entity_registry (
    entity_id,
    entity_type,
    status,
    scheduling_strategy,
    metadata,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    COALESCE($3, 'active'),
    COALESCE($4, 'manual'),
    COALESCE($5, '{}'::jsonb),
    NOW(),
    NOW()
)
ON CONFLICT (entity_id) DO UPDATE
SET
    entity_type = EXCLUDED.entity_type,
    status = EXCLUDED.status,
    scheduling_strategy = EXCLUDED.scheduling_strategy,
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
RETURNING entity_id, entity_type, status, scheduling_strategy, metadata, created_at, updated_at
`

func (q *Queries) UpsertEntity(ctx context.Context, entityID string, entityType string, column3 pgtype.Text, column4 pgtype.Text, column5 []byte) (TaskQueueEntityRegistry, error) {
	row := q.db.QueryRow(ctx, upsertEntity,
		entityID,
		entityType,
		column3,
		column4,
		column5,
	)
	var i TaskQueueEntityRegistry
	err := row.Scan(
		&i.EntityID,
		&i.EntityType,
		&i.Status,
		&i.SchedulingStrategy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertTaskForDate = `-- name: UpsertTaskForDate :one
INSERT INTO task_queue.task (
    entity_id,
    task_type,
    status,
    priority,
    attempt,
    max_attempts,
    scheduled_for,
    run_on
) VALUES (
    $1,
    $2,
    'pending',
    COALESCE($3, 0),
    0,
    $4,
    $5,
    $6
)
ON CONFLICT (entity_id, task_type, run_on)
WHERE run_on IS NOT NULL
DO UPDATE SET
    scheduled_for = COALESCE(task_queue.task.scheduled_for, EXCLUDED.scheduled_for),
    priority = GREATEST(task_queue.task.priority, EXCLUDED.priority),
    updated_at = NOW()
RETURNING task_id, entity_id, task_type, status, priority, attempt, max_attempts, last_error, worker_id, scheduled_for, started_at, completed_at, run_on, queue_message_id, created_at, updated_at
`

func (q *Queries) UpsertTaskForDate(ctx context.Context, entityID string, taskType string, column3 pgtype.Int4, maxAttempts int32, scheduledFor time.Time, runOn pgtype.Date) (TaskQueueTask, error) {
	row := q.db.QueryRow(ctx, upsertTaskForDate,
		entityID,
		taskType,
		column3,
		maxAttempts,
		scheduledFor,
		runOn,
	)
	var i TaskQueueTask
	err := row.Scan(
		&i.TaskID,
		&i.EntityID,
		&i.TaskType,
		&i.Status,
		&i.Priority,
		&i.Attempt,
		&i.MaxAttempts,
		&i.LastError,
		&i.WorkerID,
		&i.ScheduledFor,
		&i.StartedAt,
		&i.CompletedAt,
		&i.RunOn,
		&i.QueueMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
