// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const archive = `-- name: Archive :one
SELECT pgmq.archive(
    $1,
    $2::bigint
)::bool AS archived
`

func (q *Queries) Archive(ctx context.Context, queueName string, msgID int64) (bool, error) {
	row := q.db.QueryRow(ctx, archive, queueName, msgID)
	var archived bool
	err := row.Scan(&archived)
	return archived, err
}

const archiveBatch = `-- name: ArchiveBatch :many
SELECT msg_id::bigint AS msg_id
FROM pgmq.archive(
    $1,
    $2::bigint[]
) AS msg_id
`

func (q *Queries) ArchiveBatch(ctx context.Context, queueName string, msgIds []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, archiveBatch, queueName, msgIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var msg_id int64
		if err := rows.Scan(&msg_id); err != nil {
			return nil, err
		}
		items = append(items, msg_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createPartitionedQueue = `-- name: CreatePartitionedQueue :exec
SELECT pgmq.create_partitioned(
    $1,
    $2,
    $3
)
`

func (q *Queries) CreatePartitionedQueue(ctx context.Context, queueName string, partitionInterval string, retentionInterval string) error {
	_, err := q.db.Exec(ctx, createPartitionedQueue, queueName, partitionInterval, retentionInterval)
	return err
}

const createQueue = `-- name: CreateQueue :exec
SELECT pgmq.create($1)
`

func (q *Queries) CreateQueue(ctx context.Context, queueName string) error {
	_, err := q.db.Exec(ctx, createQueue, queueName)
	return err
}

const createUnloggedQueue = `-- name: CreateUnloggedQueue :exec
SELECT pgmq.create_unlogged($1)
`

func (q *Queries) CreateUnloggedQueue(ctx context.Context, queueName string) error {
	_, err := q.db.Exec(ctx, createUnloggedQueue, queueName)
	return err
}

const delete = `-- name: Delete :one
SELECT pgmq.delete(
    $1,
    $2::bigint
)::bool AS deleted
`

func (q *Queries) Delete(ctx context.Context, queueName string, msgID int64) (bool, error) {
	row := q.db.QueryRow(ctx, delete, queueName, msgID)
	var deleted bool
	err := row.Scan(&deleted)
	return deleted, err
}

const deleteBatch = `-- name: DeleteBatch :many
SELECT msg_id::bigint AS msg_id
FROM pgmq.delete(
    $1,
    $2::bigint[]
) AS msg_id
`

func (q *Queries) DeleteBatch(ctx context.Context, queueName string, msgIds []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, deleteBatch, queueName, msgIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var msg_id int64
		if err := rows.Scan(&msg_id); err != nil {
			return nil, err
		}
		items = append(items, msg_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dropQueue = `-- name: DropQueue :one
SELECT pgmq.drop_queue($1)::bool AS dropped
`

func (q *Queries) DropQueue(ctx context.Context, queueName string) (bool, error) {
	row := q.db.QueryRow(ctx, dropQueue, queueName)
	var dropped bool
	err := row.Scan(&dropped)
	return dropped, err
}

const getAllQueueMetrics = `-- name: GetAllQueueMetrics :many
SELECT
    queue_name::text AS queue_name,
    queue_length::bigint AS queue_length,
    newest_msg_age_sec::int AS newest_msg_age_sec,
    oldest_msg_age_sec::int AS oldest_msg_age_sec,
    total_messages::bigint AS total_messages,
    scrape_time::timestamptz AS scrape_time
FROM pgmq.metrics_all()
`

type GetAllQueueMetricsRow struct {
	QueueName       string    `db:"queue_name" json:"queue_name"`
	QueueLength     int64     `db:"queue_length" json:"queue_length"`
	NewestMsgAgeSec int32     `db:"newest_msg_age_sec" json:"newest_msg_age_sec"`
	OldestMsgAgeSec int32     `db:"oldest_msg_age_sec" json:"oldest_msg_age_sec"`
	TotalMessages   int64     `db:"total_messages" json:"total_messages"`
	ScrapeTime      time.Time `db:"scrape_time" json:"scrape_time"`
}

func (q *Queries) GetAllQueueMetrics(ctx context.Context) ([]GetAllQueueMetricsRow, error) {
	rows, err := q.db.Query(ctx, getAllQueueMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllQueueMetricsRow{}
	for rows.Next() {
		var i GetAllQueueMetricsRow
		if err := rows.Scan(
			&i.QueueName,
			&i.QueueLength,
			&i.NewestMsgAgeSec,
			&i.OldestMsgAgeSec,
			&i.TotalMessages,
			&i.ScrapeTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueInfo = `-- name: GetQueueInfo :one
SELECT
    queue_name::text AS queue_name,
    is_partitioned::bool AS is_partitioned,
    is_unlogged::bool AS is_unlogged,
    created_at::timestamptz AS created_at
FROM pgmq.list_queues()
WHERE queue_name = $1
`

type GetQueueInfoRow struct {
	QueueName     string    `db:"queue_name" json:"queue_name"`
	IsPartitioned bool      `db:"is_partitioned" json:"is_partitioned"`
	IsUnlogged    bool      `db:"is_unlogged" json:"is_unlogged"`
	CreatedAt     time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) GetQueueInfo(ctx context.Context, queueName pgtype.Text) (GetQueueInfoRow, error) {
	row := q.db.QueryRow(ctx, getQueueInfo, queueName)
	var i GetQueueInfoRow
	err := row.Scan(
		&i.QueueName,
		&i.IsPartitioned,
		&i.IsUnlogged,
		&i.CreatedAt,
	)
	return i, err
}

const getQueueMetrics = `-- name: GetQueueMetrics :one

SELECT
    queue_name::text AS queue_name,
    queue_length::bigint AS queue_length,
    newest_msg_age_sec::int AS newest_msg_age_sec,
    oldest_msg_age_sec::int AS oldest_msg_age_sec,
    total_messages::bigint AS total_messages,
    scrape_time::timestamptz AS scrape_time
FROM pgmq.metrics($1)
`

type GetQueueMetricsRow struct {
	QueueName       string    `db:"queue_name" json:"queue_name"`
	QueueLength     int64     `db:"queue_length" json:"queue_length"`
	NewestMsgAgeSec int32     `db:"newest_msg_age_sec" json:"newest_msg_age_sec"`
	OldestMsgAgeSec int32     `db:"oldest_msg_age_sec" json:"oldest_msg_age_sec"`
	TotalMessages   int64     `db:"total_messages" json:"total_messages"`
	ScrapeTime      time.Time `db:"scrape_time" json:"scrape_time"`
}

// ============================================
// PGMQ METRICS QUERIES
// ============================================
func (q *Queries) GetQueueMetrics(ctx context.Context, queueName string) (GetQueueMetricsRow, error) {
	row := q.db.QueryRow(ctx, getQueueMetrics, queueName)
	var i GetQueueMetricsRow
	err := row.Scan(
		&i.QueueName,
		&i.QueueLength,
		&i.NewestMsgAgeSec,
		&i.OldestMsgAgeSec,
		&i.TotalMessages,
		&i.ScrapeTime,
	)
	return i, err
}

const listQueues = `-- name: ListQueues :many

SELECT
    queue_name::text AS queue_name,
    is_partitioned::bool AS is_partitioned,
    is_unlogged::bool AS is_unlogged,
    created_at::timestamptz AS created_at
FROM pgmq.list_queues()
`

type ListQueuesRow struct {
	QueueName     string    `db:"queue_name" json:"queue_name"`
	IsPartitioned bool      `db:"is_partitioned" json:"is_partitioned"`
	IsUnlogged    bool      `db:"is_unlogged" json:"is_unlogged"`
	CreatedAt     time.Time `db:"created_at" json:"created_at"`
}

// ============================================
// PGMQ QUEUE MANAGEMENT QUERIES
// ============================================
func (q *Queries) ListQueues(ctx context.Context) ([]ListQueuesRow, error) {
	rows, err := q.db.Query(ctx, listQueues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQueuesRow{}
	for rows.Next() {
		var i ListQueuesRow
		if err := rows.Scan(
			&i.QueueName,
			&i.IsPartitioned,
			&i.IsUnlogged,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pop = `-- name: Pop :many
SELECT
    msg_id::bigint AS msg_id,
    read_ct::int AS read_ct,
    enqueued_at::timestamptz AS enqueued_at,
    vt::timestamptz AS vt,
    message::jsonb AS message,
    headers::jsonb AS headers
FROM pgmq.pop($1)
`

type PopRow struct {
	MsgID      int64           `db:"msg_id" json:"msg_id"`
	ReadCt     int32           `db:"read_ct" json:"read_ct"`
	EnqueuedAt time.Time       `db:"enqueued_at" json:"enqueued_at"`
	Vt         time.Time       `db:"vt" json:"vt"`
	Message    json.RawMessage `db:"message" json:"message"`
	Headers    json.RawMessage `db:"headers" json:"headers"`
}

func (q *Queries) Pop(ctx context.Context, queueName string) ([]PopRow, error) {
	rows, err := q.db.Query(ctx, pop, queueName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PopRow{}
	for rows.Next() {
		var i PopRow
		if err := rows.Scan(
			&i.MsgID,
			&i.ReadCt,
			&i.EnqueuedAt,
			&i.Vt,
			&i.Message,
			&i.Headers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purgeQueue = `-- name: PurgeQueue :one
SELECT pgmq.purge_queue($1)::bigint AS count
`

func (q *Queries) PurgeQueue(ctx context.Context, queueName string) (int64, error) {
	row := q.db.QueryRow(ctx, purgeQueue, queueName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const read = `-- name: Read :many
SELECT
    msg_id::bigint AS msg_id,
    read_ct::int AS read_ct,
    enqueued_at::timestamptz AS enqueued_at,
    vt::timestamptz AS vt,
    message::jsonb AS message,
    headers::jsonb AS headers
FROM pgmq.read(
    $1,
    $2,
    $3
)
`

type ReadRow struct {
	MsgID      int64           `db:"msg_id" json:"msg_id"`
	ReadCt     int32           `db:"read_ct" json:"read_ct"`
	EnqueuedAt time.Time       `db:"enqueued_at" json:"enqueued_at"`
	Vt         time.Time       `db:"vt" json:"vt"`
	Message    json.RawMessage `db:"message" json:"message"`
	Headers    json.RawMessage `db:"headers" json:"headers"`
}

func (q *Queries) Read(ctx context.Context, queueName string, vtSeconds int32, numMessages int32) ([]ReadRow, error) {
	rows, err := q.db.Query(ctx, read, queueName, vtSeconds, numMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReadRow{}
	for rows.Next() {
		var i ReadRow
		if err := rows.Scan(
			&i.MsgID,
			&i.ReadCt,
			&i.EnqueuedAt,
			&i.Vt,
			&i.Message,
			&i.Headers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const send = `-- name: Send :one

SELECT pgmq.send(
    $1,
    $2,
    $3::int
)::bigint AS msg_id
`

// ============================================
// PGMQ MESSAGE OPERATIONS
// ============================================
func (q *Queries) Send(ctx context.Context, queueName string, message json.RawMessage, delaySeconds int32) (int64, error) {
	row := q.db.QueryRow(ctx, send, queueName, message, delaySeconds)
	var msg_id int64
	err := row.Scan(&msg_id)
	return msg_id, err
}

const sendBatch = `-- name: SendBatch :many
SELECT msg_id::bigint AS msg_id
FROM pgmq.send_batch(
    $1,
    $2::jsonb[],
    $3::int
) AS msg_id
`

func (q *Queries) SendBatch(ctx context.Context, queueName string, messages []json.RawMessage, delaySeconds int32) ([]int64, error) {
	rows, err := q.db.Query(ctx, sendBatch, queueName, messages, delaySeconds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var msg_id int64
		if err := rows.Scan(&msg_id); err != nil {
			return nil, err
		}
		items = append(items, msg_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setVT = `-- name: SetVT :many
SELECT
    msg_id::bigint AS msg_id,
    read_ct::int AS read_ct,
    enqueued_at::timestamptz AS enqueued_at,
    vt::timestamptz AS vt,
    message::jsonb AS message,
    headers::jsonb AS headers
FROM pgmq.set_vt(
    $1,
    $2::bigint,
    $3::int
)
`

type SetVTRow struct {
	MsgID      int64           `db:"msg_id" json:"msg_id"`
	ReadCt     int32           `db:"read_ct" json:"read_ct"`
	EnqueuedAt time.Time       `db:"enqueued_at" json:"enqueued_at"`
	Vt         time.Time       `db:"vt" json:"vt"`
	Message    json.RawMessage `db:"message" json:"message"`
	Headers    json.RawMessage `db:"headers" json:"headers"`
}

func (q *Queries) SetVT(ctx context.Context, queueName string, msgID int64, vtSeconds int32) ([]SetVTRow, error) {
	rows, err := q.db.Query(ctx, setVT, queueName, msgID, vtSeconds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SetVTRow{}
	for rows.Next() {
		var i SetVTRow
		if err := rows.Scan(
			&i.MsgID,
			&i.ReadCt,
			&i.EnqueuedAt,
			&i.Vt,
			&i.Message,
			&i.Headers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
