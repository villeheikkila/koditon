/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Koditon API
 * OpenAPI spec version: 0.1.0
 */
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import useSwr from 'swr';
import type {
  Arguments,
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

import type {
  ErrorModel,
  FetchTransactionsOutputBody,
  HealthResponse,
  HintatiedotCitiesResponse,
  ListCities200,
  ListTransactions200,
  ListTransactionsParams,
  PingRequest,
  PingResponse,
  SyncHintatiedotRequest,
  SyncHintatiedotResponse
} from '.././model';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



  
  
  
/**
 * @summary List cities with neighborhoods
 */
export const listCities = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListCities200>> => {
    return axios.default.get(
      `/api/v1/cities`,options
    );
  }



export const getListCitiesKey = () => [`/api/v1/cities`] as const;

export type ListCitiesQueryResult = NonNullable<Awaited<ReturnType<typeof listCities>>>
export type ListCitiesQueryError = AxiosError<ErrorModel>

/**
 * @summary List cities with neighborhoods
 */
export const useListCities = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listCities>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListCitiesKey() : null);
  const swrFn = () => listCities(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * @summary Fetch cities from Hintatiedot
 */
export const fetchHintatiedotCities = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HintatiedotCitiesResponse>> => {
    return axios.default.get(
      `/api/v1/hintatiedot/cities`,options
    );
  }



export const getFetchHintatiedotCitiesKey = () => [`/api/v1/hintatiedot/cities`] as const;

export type FetchHintatiedotCitiesQueryResult = NonNullable<Awaited<ReturnType<typeof fetchHintatiedotCities>>>
export type FetchHintatiedotCitiesQueryError = AxiosError<ErrorModel>

/**
 * @summary Fetch cities from Hintatiedot
 */
export const useFetchHintatiedotCities = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof fetchHintatiedotCities>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFetchHintatiedotCitiesKey() : null);
  const swrFn = () => fetchHintatiedotCities(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * @summary Sync a city from Hintatiedot
 */
export const syncHintatiedotCity = (
    syncHintatiedotRequest: NonReadonly<SyncHintatiedotRequest>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SyncHintatiedotResponse>> => {
    return axios.default.post(
      `/api/v1/hintatiedot/sync`,
      syncHintatiedotRequest,options
    );
  }



export const getSyncHintatiedotCityMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: NonReadonly<SyncHintatiedotRequest> }) => {
    return syncHintatiedotCity(arg, options);
  }
}
export const getSyncHintatiedotCityMutationKey = () => [`/api/v1/hintatiedot/sync`] as const;

export type SyncHintatiedotCityMutationResult = NonNullable<Awaited<ReturnType<typeof syncHintatiedotCity>>>
export type SyncHintatiedotCityMutationError = AxiosError<ErrorModel>

/**
 * @summary Sync a city from Hintatiedot
 */
export const useSyncHintatiedotCity = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof syncHintatiedotCity>>, TError, Key, NonReadonly<SyncHintatiedotRequest>, Awaited<ReturnType<typeof syncHintatiedotCity>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSyncHintatiedotCityMutationKey();
  const swrFn = getSyncHintatiedotCityMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * @summary Echo a message
 */
export const ping = (
    pingRequest: NonReadonly<PingRequest>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PingResponse>> => {
    return axios.default.post(
      `/api/v1/ping`,
      pingRequest,options
    );
  }



export const getPingMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: NonReadonly<PingRequest> }) => {
    return ping(arg, options);
  }
}
export const getPingMutationKey = () => [`/api/v1/ping`] as const;

export type PingMutationResult = NonNullable<Awaited<ReturnType<typeof ping>>>
export type PingMutationError = AxiosError<ErrorModel>

/**
 * @summary Echo a message
 */
export const usePing = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof ping>>, TError, Key, NonReadonly<PingRequest>, Awaited<ReturnType<typeof ping>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPingMutationKey();
  const swrFn = getPingMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * @summary List transactions for neighborhoods
 */
export const listTransactions = (
    params?: ListTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListTransactions200>> => {
    return axios.default.get(
      `/api/v1/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListTransactionsKey = (params?: ListTransactionsParams,) => [`/api/v1/transactions`, ...(params ? [params]: [])] as const;

export type ListTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof listTransactions>>>
export type ListTransactionsQueryError = AxiosError<ErrorModel>

/**
 * @summary List transactions for neighborhoods
 */
export const useListTransactions = <TError = AxiosError<ErrorModel>>(
  params?: ListTransactionsParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listTransactions>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListTransactionsKey(params) : null);
  const swrFn = () => listTransactions(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * @summary Fetch transactions from Hintatiedot for Helsinki
 */
export const fetchTransactions = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FetchTransactionsOutputBody>> => {
    return axios.default.post(
      `/api/v1/transactions/fetch`,undefined,options
    );
  }



export const getFetchTransactionsMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }) => {
    return fetchTransactions(options);
  }
}
export const getFetchTransactionsMutationKey = () => [`/api/v1/transactions/fetch`] as const;

export type FetchTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof fetchTransactions>>>
export type FetchTransactionsMutationError = AxiosError<ErrorModel>

/**
 * @summary Fetch transactions from Hintatiedot for Helsinki
 */
export const useFetchTransactions = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof fetchTransactions>>, TError, Key, Arguments, Awaited<ReturnType<typeof fetchTransactions>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getFetchTransactionsMutationKey();
  const swrFn = getFetchTransactionsMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
/**
 * @summary Health check
 */
export const healthz = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HealthResponse>> => {
    return axios.default.get(
      `/healthz`,options
    );
  }



export const getHealthzKey = () => [`/healthz`] as const;

export type HealthzQueryResult = NonNullable<Awaited<ReturnType<typeof healthz>>>
export type HealthzQueryError = AxiosError<ErrorModel>

/**
 * @summary Health check
 */
export const useHealthz = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof healthz>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getHealthzKey() : null);
  const swrFn = () => healthz(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
