/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Koditon API
 * OpenAPI spec version: 0.1.0
 */
import type {
  ErrorModel,
  FetchTransactionsOutputBody,
  HealthResponse,
  HintatiedotCitiesResponse,
  ListCities200,
  ListTransactions200,
  ListTransactionsParams,
  PingRequest,
  PingResponse,
  SyncHintatiedotRequest,
  SyncHintatiedotResponse
} from '.././models';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;

/**
 * @summary List cities with neighborhoods
 */
export type listCitiesResponse200 = {
  data: ListCities200
  status: 200
}

export type listCitiesResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listCitiesResponseSuccess = (listCitiesResponse200) & {
  headers: Headers;
};
export type listCitiesResponseError = (listCitiesResponseDefault) & {
  headers: Headers;
};

export type listCitiesResponse = (listCitiesResponseSuccess | listCitiesResponseError)

export const getListCitiesUrl = () => {


  

  return `http://localhost:8080/api/v1/cities`
}

export const listCities = async ( options?: RequestInit): Promise<listCitiesResponse> => {
  
  const res = await fetch(getListCitiesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCitiesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCitiesResponse
}


/**
 * @summary Fetch cities from Hintatiedot
 */
export type fetchHintatiedotCitiesResponse200 = {
  data: HintatiedotCitiesResponse
  status: 200
}

export type fetchHintatiedotCitiesResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type fetchHintatiedotCitiesResponseSuccess = (fetchHintatiedotCitiesResponse200) & {
  headers: Headers;
};
export type fetchHintatiedotCitiesResponseError = (fetchHintatiedotCitiesResponseDefault) & {
  headers: Headers;
};

export type fetchHintatiedotCitiesResponse = (fetchHintatiedotCitiesResponseSuccess | fetchHintatiedotCitiesResponseError)

export const getFetchHintatiedotCitiesUrl = () => {


  

  return `http://localhost:8080/api/v1/hintatiedot/cities`
}

export const fetchHintatiedotCities = async ( options?: RequestInit): Promise<fetchHintatiedotCitiesResponse> => {
  
  const res = await fetch(getFetchHintatiedotCitiesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchHintatiedotCitiesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchHintatiedotCitiesResponse
}


/**
 * @summary Sync a city from Hintatiedot
 */
export type syncHintatiedotCityResponse200 = {
  data: SyncHintatiedotResponse
  status: 200
}

export type syncHintatiedotCityResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type syncHintatiedotCityResponseSuccess = (syncHintatiedotCityResponse200) & {
  headers: Headers;
};
export type syncHintatiedotCityResponseError = (syncHintatiedotCityResponseDefault) & {
  headers: Headers;
};

export type syncHintatiedotCityResponse = (syncHintatiedotCityResponseSuccess | syncHintatiedotCityResponseError)

export const getSyncHintatiedotCityUrl = () => {


  

  return `http://localhost:8080/api/v1/hintatiedot/sync`
}

export const syncHintatiedotCity = async (syncHintatiedotRequest: NonReadonly<SyncHintatiedotRequest>, options?: RequestInit): Promise<syncHintatiedotCityResponse> => {
  
  const res = await fetch(getSyncHintatiedotCityUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      syncHintatiedotRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: syncHintatiedotCityResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as syncHintatiedotCityResponse
}


/**
 * @summary Echo a message
 */
export type pingResponse200 = {
  data: PingResponse
  status: 200
}

export type pingResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type pingResponseSuccess = (pingResponse200) & {
  headers: Headers;
};
export type pingResponseError = (pingResponseDefault) & {
  headers: Headers;
};

export type pingResponse = (pingResponseSuccess | pingResponseError)

export const getPingUrl = () => {


  

  return `http://localhost:8080/api/v1/ping`
}

export const ping = async (pingRequest: NonReadonly<PingRequest>, options?: RequestInit): Promise<pingResponse> => {
  
  const res = await fetch(getPingUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pingRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: pingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as pingResponse
}


/**
 * @summary List transactions for neighborhoods
 */
export type listTransactionsResponse200 = {
  data: ListTransactions200
  status: 200
}

export type listTransactionsResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listTransactionsResponseSuccess = (listTransactionsResponse200) & {
  headers: Headers;
};
export type listTransactionsResponseError = (listTransactionsResponseDefault) & {
  headers: Headers;
};

export type listTransactionsResponse = (listTransactionsResponseSuccess | listTransactionsResponseError)

export const getListTransactionsUrl = (params?: ListTransactionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:8080/api/v1/transactions?${stringifiedParams}` : `http://localhost:8080/api/v1/transactions`
}

export const listTransactions = async (params?: ListTransactionsParams, options?: RequestInit): Promise<listTransactionsResponse> => {
  
  const res = await fetch(getListTransactionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listTransactionsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listTransactionsResponse
}


/**
 * @summary Fetch transactions from Hintatiedot for Helsinki
 */
export type fetchTransactionsResponse200 = {
  data: FetchTransactionsOutputBody
  status: 200
}

export type fetchTransactionsResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type fetchTransactionsResponseSuccess = (fetchTransactionsResponse200) & {
  headers: Headers;
};
export type fetchTransactionsResponseError = (fetchTransactionsResponseDefault) & {
  headers: Headers;
};

export type fetchTransactionsResponse = (fetchTransactionsResponseSuccess | fetchTransactionsResponseError)

export const getFetchTransactionsUrl = () => {


  

  return `http://localhost:8080/api/v1/transactions/fetch`
}

export const fetchTransactions = async ( options?: RequestInit): Promise<fetchTransactionsResponse> => {
  
  const res = await fetch(getFetchTransactionsUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchTransactionsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchTransactionsResponse
}


/**
 * @summary Health check
 */
export type healthzResponse200 = {
  data: HealthResponse
  status: 200
}

export type healthzResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type healthzResponseSuccess = (healthzResponse200) & {
  headers: Headers;
};
export type healthzResponseError = (healthzResponseDefault) & {
  headers: Headers;
};

export type healthzResponse = (healthzResponseSuccess | healthzResponseError)

export const getHealthzUrl = () => {


  

  return `http://localhost:8080/healthz`
}

export const healthz = async ( options?: RequestInit): Promise<healthzResponse> => {
  
  const res = await fetch(getHealthzUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthzResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthzResponse
}


