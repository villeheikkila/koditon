/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Koditon API
 * OpenAPI spec version: 0.1.0
 */
import type {
  ErrorModel,
  HealthResponse,
  PingRequest,
  PingResponse
} from '.././models';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;

/**
 * @summary Echo a message
 */
export type pingResponse200 = {
  data: PingResponse
  status: 200
}

export type pingResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type pingResponseSuccess = (pingResponse200) & {
  headers: Headers;
};
export type pingResponseError = (pingResponseDefault) & {
  headers: Headers;
};

export type pingResponse = (pingResponseSuccess | pingResponseError)

export const getPingUrl = () => {


  

  return `http://localhost:8080/api/v1/ping`
}

export const ping = async (pingRequest: NonReadonly<PingRequest>, options?: RequestInit): Promise<pingResponse> => {
  
  const res = await fetch(getPingUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pingRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: pingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as pingResponse
}


/**
 * @summary Health check
 */
export type healthzResponse200 = {
  data: HealthResponse
  status: 200
}

export type healthzResponseDefault = {
  data: ErrorModel
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type healthzResponseSuccess = (healthzResponse200) & {
  headers: Headers;
};
export type healthzResponseError = (healthzResponseDefault) & {
  headers: Headers;
};

export type healthzResponse = (healthzResponseSuccess | healthzResponseError)

export const getHealthzUrl = () => {


  

  return `http://localhost:8080/healthz`
}

export const healthz = async ( options?: RequestInit): Promise<healthzResponse> => {
  
  const res = await fetch(getHealthzUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthzResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthzResponse
}


